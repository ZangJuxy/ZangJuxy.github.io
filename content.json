{"meta":{"title":"臧臧","subtitle":"","description":"","author":"臧臧","url":"http://example.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"10-30","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"09-14","excerpt":""},{"title":"标签","text":"","path":"categories/index.html","date":"09-14","excerpt":""},{"title":"友链","text":"半月无霜世界上有10种人，一种人懂编程，另一种则不懂","path":"friends/index.html","date":"06-17","excerpt":""},{"title":"","text":"var github_canlendar = (git_user, git_color) => { var git_githubapiurl = \"https://python-github-calendar-api.vercel.app/api?\" + git_user; var git_fixed = 'fixed'; var git_px = 'px'; var git_month = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月']; var git_monthchange = []; var git_oneyearbeforeday = ''; var git_thisday = ''; var git_amonthago = ''; var git_aweekago = ''; var git_weekdatacore = 0; var git_datacore = 0; var git_total = 0; var git_datadate = ''; var git_git_data = []; var git_positionplusdata = []; var git_firstweek = []; var git_lastweek = []; var git_beforeweek = []; var git_thisweekdatacore = 0; var git_mounthbeforeday = 0; var git_mounthfirstindex = 0; var git_crispedges = 'crispedges'; var git_thisdayindex = 0; var git_amonthagoindex = 0; var git_amonthagoweek = []; var git_firstdate = []; var git_first2date = []; var git_montharrbefore = []; var git_monthindex = 0; var retinaCanvas = (canvas, context, ratio) => { if (ratio > 1) { var canvasWidth = canvas.width; var canvasHeight = canvas.height; canvas.width = canvasWidth * ratio; canvas.height = canvasHeight * ratio; canvas.style.width = '100%'; canvas.style.height = canvasHeight + 'px'; context.scale(ratio, ratio); } }; function responsiveChart() { var ratio = window.devicePixelRatio || 1 var git_tooltip_container = document.getElementById('git_tooltip_container'); var git_x = ''; var git_y = ''; var git_span1 = ''; var git_span2 = ''; var c = document.getElementById(\"gitcanvas\"); c.style.width = '100%'; c.style.height = ''; var cmessage = document.getElementById(\"gitmessage\"); var ctx = c.getContext(\"2d\"); width = c.width = document.getElementById(\"gitcalendarcanvasbox\").offsetWidth; height = c.height = 9 * 0.96 * c.width / git_data.length; retinaCanvas(c,ctx, ratio) var linemaxwitdh = height/ 9; var lineminwitdh = 0.8 * linemaxwitdh; var setposition = {x: 0.02 * width, y: 0.025 * width}; for (var week in git_data) { weekdata = git_data[week]; for (var day in weekdata) { var dataitem = {date: \"\", count: \"\", x: 0, y: 0}; git_positionplusdata.push(dataitem); ctx.fillStyle = git_thiscolor(git_color, weekdata[day].count); setposition.y = Math.round(setposition.y * 100) / 100; dataitem.date = weekdata[day].date; dataitem.count = weekdata[day].count; dataitem.x = setposition.x; dataitem.y = setposition.y; ctx.fillRect(setposition.x, setposition.y, lineminwitdh, lineminwitdh); setposition.y = setposition.y + linemaxwitdh } setposition.y = 0.025 * width; setposition.x = setposition.x + linemaxwitdh } if (document.body.clientWidth > 700) { ctx.font = \"600 Arial\"; ctx.fillStyle = '#aaa'; ctx.fillText(\"日\", 0, 1.9 * linemaxwitdh); ctx.fillText(\"二\", 0, 3.9 * linemaxwitdh); ctx.fillText(\"四\", 0, 5.9 * linemaxwitdh); ctx.fillText(\"六\", 0, 7.9 * linemaxwitdh); var monthindexlist = width / 24; for (var index in git_monthchange) { ctx.fillText(git_monthchange[index], monthindexlist, 0.7 * linemaxwitdh); monthindexlist = monthindexlist + width / 12 } } c.onmousemove = function (event) { if (document.querySelector('.gitmessage')) { git_tooltip_container.innerHTML = \"\" } getMousePos(c, event) }; git_tooltip_container.onmousemove = function (event) { if (document.querySelector('.gitmessage')) { git_tooltip_container.innerHTML = \"\" } }; function getMousePos(canvas, event) { var rect = canvas.getBoundingClientRect(); var x = event.clientX - rect.left * (canvas.width / rect.width); var y = event.clientY - rect.top * (canvas.height / rect.height); for (var item of git_positionplusdata) { var lenthx = x - item.x; var lenthy = y - item.y; if (0 < lenthx && lenthx < lineminwitdh) { if (0 < lenthy && lenthy < lineminwitdh) { git_span1 = item.date; git_span2 = item.count; git_x = event.clientX - 100; git_y = event.clientY - 60; html = tooltip_html(git_x, git_y, git_span1, git_span2); append_div_gitcalendar(git_tooltip_container, html) } } } } } function addlastmonth() { if (git_thisdayindex === 0) { thisweekcore(52); thisweekcore(51); thisweekcore(50); thisweekcore(49); thisweekcore(48); git_thisweekdatacore += git_firstdate[6].count; git_amonthago = git_firstdate[6].date } else { thisweekcore(52); thisweekcore(51); thisweekcore(50); thisweekcore(49); thisweek2core(); git_amonthago = git_first2date[git_thisdayindex - 1].date } } function thisweek2core() { for (var i = git_thisdayindex - 1; i < git_first2date.length; i++) { git_thisweekdatacore += git_first2date[i].count } } function thisweekcore(index) { for (var item of git_data[index]) { git_thisweekdatacore += item.count } } function addlastweek() { for (var item of git_lastweek) { git_weekdatacore += item.count } } function addbeforeweek() { for (var i = git_thisdayindex; i < git_beforeweek.length; i++) { git_weekdatacore += git_beforeweek[i].count } } function addweek(data) { if (git_thisdayindex === 6) { git_aweekago = git_lastweek[0].date; addlastweek() } else { lastweek = data.contributions[51]; git_aweekago = lastweek[git_thisdayindex + 1].date; addlastweek(); addbeforeweek() } } fetch(git_githubapiurl).then(data => data.json()).then(data => { git_data = data.contributions; git_total = data.total; git_first2date = git_data[48]; git_firstdate = git_data[47]; git_firstweek = data.contributions[0]; git_lastweek = data.contributions[52]; git_beforeweek = data.contributions[51]; git_thisdayindex = git_lastweek.length - 1; git_thisday = git_lastweek[git_thisdayindex].date; git_oneyearbeforeday = git_firstweek[0].date; git_monthindex = git_thisday.substring(5, 7) * 1; git_montharrbefore = git_month.splice(git_monthindex, 12 - git_monthindex); git_monthchange = git_montharrbefore.concat(git_month); addweek(data); addlastmonth(); var html = github_main_box(git_monthchange, git_data, git_user, git_color, git_total, git_thisweekdatacore, git_weekdatacore, git_oneyearbeforeday, git_thisday, git_aweekago, git_amonthago); append_div_gitcalendar(github_container, html); if(document.getElementById('github_loading')){ document.getElementById('github_loading').remove()}; responsiveChart() }).catch(function (error) { console.log(error) }); window.addEventListener('resize', function () { responsiveChart() }) window.addEventListener('scroll', function () { if (document.querySelector('.gitmessage')) { git_tooltip_container.innerHTML = \"\" } }) var git_thiscolor = (color, x) => { if (x === 0) { var i = parseInt(x / 2); return color[0] } else if (x < 2) { return color[1] } else if (x < 20) { var i = parseInt(x / 2); return color[i] } else { return color[9] } }; var tooltip_html = (x, y, span1, span2) => { var html = ''; html += '' + span1 + '&nbsp;' + span2 + ' 次上传'; return html }; var github_canvas_box = () => { var html = ' '; return html }; var github_info_box = (user, color) => { var html = ''; html += '数据来源 @' + user + 'Less More '; return html }; var github_main_box = (monthchange, git_data, user, color, total, thisweekdatacore, weekdatacore, oneyearbeforeday, thisday, aweekago, amonthago) => { var html = ''; var canvasbox = github_canvas_box(); var infobox = github_info_box(user, color); var style = github_main_style(); html += '' + canvasbox + '' + infobox + ''; html += '过去一年提交' + total + '' + oneyearbeforeday + '&nbsp;-&nbsp;' + thisday + '最近一月提交' + thisweekdatacore + '' + amonthago + '&nbsp;-&nbsp;' + thisday + '最近一周提交' + weekdatacore + '' + aweekago + '&nbsp;-&nbsp;' + thisday + '' + style; return html }; var github_main_style = () => { style = '#github_container{text-align:center;margin:0 auto;width:100%;display:flex;display:-webkit-flex;justify-content:center;align-items:center;flex-wrap:wrap;}.gitcalendar-graph text.wday,.gitcalendar-graph text.month{font-size:10px;fill:#aaa;}.contrib-legend{text-align:right;padding:0 14px 10px 0;display:inline-block;float:right;}.contrib-legend .legend{display:inline-block;list-style:none;margin:0 5px;position:relative;bottom:-1px;padding:0;}.contrib-legend .legend li{display:inline-block;width:10px;height:10px;}.text-small{font-size:12px;color:#767676;}.gitcalendar-graph{padding:15px 0 0;text-align:center;}.contrib-column{text-align:center;border-left:1px solid #ddd;border-top:1px solid #ddd;font-size:11px;}.contrib-column-first{border-left:0;}.table-column{padding:10px;display:table-cell;flex:1;vertical-align:top;}.contrib-number{font-weight:300;line-height:1.3em;font-size:24px;display:block;}.gitcalendar img.spinner{width:70px;margin-top:50px;min-height:70px;}.monospace{text-align:center;color:#000;font-family:monospace;}.monospace a{color:#1D75AB;text-decoration:none;}.contrib-footer{font-size:11px;padding:0 10px 12px;text-align:left;width:100%;box-sizing:border-box;height:26px;}.left.text-muted{float:left;margin-left:9px;color:#767676;}.left.text-muted a{color:#4078c0;text-decoration:none;}.left.text-muted a:hover,.monospace a:hover{text-decoration:underline;}h2.f4.text-normal.mb-3{display:none;}.float-left.text-gray{float:left;}#user-activity-overview{display:none;}.day-tooltip{white-space:nowrap;position:absolute;z-index:99999;padding:10px;font-size:12px;color:#959da5;text-align:center;background:rgba(0,0,0,.85);border-radius:3px;display:none;pointer-events:none;}.day-tooltip strong{color:#dfe2e5;}.day-tooltip.is-visible{display:block;}.day-tooltip:after{position:absolute;bottom:-10px;left:50%;width:5px;height:5px;box-sizing:border-box;margin:0 0 0 -5px;content:\" \";border:5px solid transparent;border-top-color:rgba(0,0,0,.85)}.position-relative{width:100%;}@media screen and (max-width:650px){.contrib-column{display:none}}.angle-wrapper{z-index:9999;display:inline;width:200px;height:40px;position:relative;padding:5px 0;background:rgba(0,0,0,0.8);border-radius:8px;text-align:center;color:white;}.angle-box{position:fixed;padding:10px}.angle-wrapper span{padding-bottom:1em;}.angle-wrapper:before{content:\"\";width:0;height:0;border:10px solid transparent;border-top-color:rgba(0,0,0,0.8);position:absolute;left:47.5%;top:100%;}'; return style } }; var append_div_gitcalendar = (parent, text) => { if (typeof text === 'string') { var temp = document.createElement('div'); temp.innerHTML = text; var frag = document.createDocumentFragment(); while (temp.firstChild) { frag.appendChild(temp.firstChild) } parent.appendChild(frag) } else { parent.appendChild(text) } }; var loading_git = (color) => { loading = ''; return loading }; (function(){ var git_user = 'ZangJuxy'; // 这里更改为你的github 用户名 var github_container = document.getElementById('github_container'); var github_loading = document.getElementById('github_loading'); var git_purple = ['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f',]; var git_green = ['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620']; var git_blue = ['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c',]; var git_color = git_green; if (github_container) { append_div_gitcalendar(github_container, loading_git(git_color[4])); github_canlendar(git_user, git_color) } else { console.log('nonono'); } })()","path":"githubcalendar/index.js","date":"12-04","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"09-14","excerpt":""},{"title":"我的故事","text":"臧臧我的故事 关于我 我是臧臧一个刚刚接本成功的小FW，00后，目前是小白一枚。虽然心中不甘，但是目前确实是 Worst One 。目标是成为全栈工程师、系统架构师。虽然前路迷茫，但是我会一步一步往前走。 个人经历 大概是从大学开始吧才知道自己究竟想干嘛，一边忙着打球锻炼身体课下教球做兼职一边用于课余时间学习java，我真正入门还是要从哔哩哔哩上的一个up主(狂神说Java)说起，偶然看到他的教学视频进去看发现讲的很好，也不是很乏味让我更加有了兴趣。我就一点一点学，到后来大三了要出去找工作才知道专科生多么被人看不起(没有贬低专科生的意思，可是事实就是这样)，然后决心接本，这就不得不提起我的一个好兄弟尚*涛是他让我知道怎么去学习备考。2020年10月的时候我们在外边一起租房子学习，那时候自己做饭比点外卖便宜多了但是我也不会做饭，他就和我说做饭的事情交给他然后我打打下手就可以，我们两个互相监督不浪费时间最终都考上了本科，不过我感觉本科不是结束而是开始。在此搭建这个博客 为了自己做笔记 为了分享自己的经历吧 同时也会记录一些自己的日常","path":"me/index.html","date":"08-01","excerpt":""},{"title":"","text":"// 如果想变换轮播方式等，进阶的话，可以看这个 https://github.surmon.me/vue-awesome-swiper/ // 当然你也可以引入jquery插件，都可以的, 不只是轮播图，其他特效也可以 new Vue({ el: \"#myHistorySwiper\", // el不要是最外面的id_name，应该是html: ''里的div的id data: function () { return { swiperOption: { effect: \"cube\", // 轮播特效 loop: true, // 循环 autoplay: { delay: 2500, disableOnInteraction: false, }, }, content: [], }; }, computed: { swiper() { return this.$refs.myhistoryswiper.$swiper; }, }, created() { this.getHistoryList(); }, methods: { // 鼠标移入停止轮播 stopAutoPlay() { this.swiperOption.autoplay && this.swiper.autoplay.stop(); }, // 鼠标移出开始轮播 startAutoPlay() { this.swiperOption.autoplay && this.swiper.autoplay.start(); }, // 请求开源api, 获取历史上的今天数据 getHistoryList() { fetch(\"https://tenapi.cn/lishi/?format=json\", { method: \"GET\", // *GET, POST, PUT, DELETE, etc. }) .then((res) => { return res.json(); }) .then((data) => { this.content = data.content; }) .catch((err) => { console.log(\"err\", err); }); }, }, });","path":"historyToday/index.js","date":"10-30","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-30","excerpt":""},{"title":"","text":"var htmer_time = document.getElementById(\"htmer_time\"); var htmer_time_time = null; function setTime() { var create_time = Math.round( new Date(Date.UTC(2020, 2, 26, 6, 45, 0)).getTime() / 1000 ); var timestamp = Math.round( (new Date().getTime() + 8 * 60 * 60 * 1000) / 1000 ); currentTime = secondToDate(timestamp - create_time); currentTimeHtml = currentTime[0] + \" 年 \" + currentTime[1] + \" 天 \" + currentTime[2] + \" 时 \" + currentTime[3] + \" 分 \" + currentTime[4] + \" 秒\"; htmer_time.innerHTML = currentTimeHtml; } function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second >= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second >= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second >= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second >= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second > 0) { time[4] = second; } return time; } if (htmer_time) { htmer_time_time = setInterval(setTime, 1000); } else { clearInterval(htmer_time_time); }","path":"love/index.js","date":"11-04","excerpt":""},{"title":"","text":".weibo-container { width: 100%; line-height: 30px; display: flex; justify-content: space-between; font-size: 12px; height: 30px; } .weibo-container .left { display: flex; } .weibo-container .name { margin-left: 5px; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 1; overflow: hidden; } #myWeibo .warp { height: 300px; width: 100%; margin: 0 auto; overflow: hidden; } .weibo-container .order { color: #fe962e; } .weibo-container .name a{ color: black; } .weibo-container .name a:hover { text-decoration: underline; color: red; } .weibo-container .red { color: red; }","path":"weibo/index.css","date":"10-30","excerpt":""},{"title":"","text":"new Vue({ el: \"#myWeibo\", // el不要是最外面的id_name，应该是html: ''里的div的id data: function () { return { content: [], classOption: { singleHeight: 30, }, }; }, created() { this.getWeiboList(); }, methods: { // 请求开源api, 获取历史上的今天数据 getWeiboList() { fetch(\"https://tenapi.cn/resou/\", { method: \"GET\", // *GET, POST, PUT, DELETE, etc. }) .then((res) => { return res.json(); }) .then((data) => { this.content = data.list; }) .catch((err) => { console.log(\"err\", err); }); }, }, });","path":"weibo/index.js","date":"10-30","excerpt":""}],"posts":[{"title":"SpringBoot整合rabbitMq","text":"SpringBoot整合rabbitMq一、介绍消息队列（Message Queue）简称mq，本文将介绍SpringBoot整合rabbitmq的功能使用 队列是一种数据结构，就像排队一样，遵循先进先出的原则。 而消息队列是一种消息中间件，在项目中我们可以将消息打包放入队列，再由消费者监听进行处理数据，再进行业务的处理 那么使用队列可以带来哪些好处呢 解耦 异步 流量削峰/限流 原本的程序再装上了消息中间件后，有哪些事需要特别注意的呢 高可用：简单点就是说，要保证消息中间件不要那么容易崩溃。作为桥梁的消息中间件崩溃了，那整个系统就相当于崩溃的情况的 数据丢失 重复消费 顺序性 话不多说，优缺点的例子以后补上，先来开始使用rabbitmq吧 二、rabbitmq的安装，项目依赖和相关配置安装我就不多说了，我是通过这篇博客安装成功的，大家可以试试。 本文rabbitmq使用的版本是3.8.5，在不同版本下可能会出现与本文不同的结果，甚至是报错 创建springBoot项目，引入项目依赖，本文使用的springBoot版本为2.4.2，算是比较新的了 &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-amqp&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>fastjson&lt;/artifactId> &lt;version>1.2.73&lt;/version> &lt;/dependency> &lt;/dependencies> 配置yaml文件 server: port: 8011 spring: application: name: rabbitmq_learn rabbitmq: host: 主机名 port: 端口 username: 帐号 password: 密码 三、队列类型3.1、简单模式首先创建队列常量类RabbitmqConstant，声明常量为队列名称，当然也可以写在配置文件 public class RabbitmqConstant &#123; /** ================ 简单模式 begin ================ */ public static final String LEARN_SIMPLE_QUEUE = \"LEARN.SIMPLE.QUEUE\"; /** ================ 简单模式 end ================ */ &#125; 创建队列配置类SimpleRabbitmqConfig，声明创建队列 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SimpleRabbitmqConfig &#123; @Bean(name = RabbitmqConstant.LEARN_SIMPLE_QUEUE) public Queue queue()&#123; return new Queue(RabbitmqConstant.LEARN_SIMPLE_QUEUE, false, false, true); &#125; &#125; 简单说明一下，这几个参数的意思 参数名 说明 name 定义队列的名称 durable 是否持久化，重启rabbitmq队列是否还存在，默认为true exclusive 是否排他，是否仅保持一个连接，且该连接断线后，此队列会被删除，默认为false autoDelete 是否自动删除，当队列没有消息一段时间后自动删除，默认为false arguments 参数，可以设置队列的最大消息数等 创建此队列的生产者类SimpleMsgProducer，提供send方法进行生产消息 package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class SimpleMsgProducer &#123; @Autowired private AmqpTemplate amqpTemplate; public void send(SendBaseMsgReq req)&#123; amqpTemplate.convertAndSend(RabbitmqConstant.LEARN_SIMPLE_QUEUE, JSON.toJSONString(req)); &#125; &#125; 创建此队列的消费者类SimpleMsgConsumer，监听队列进行消费 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class SimpleMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_SIMPLE_QUEUE) public void simpleMsgConsumerListener(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"简单模式消费：&#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private SimpleMsgProducer simpleMsgProducer; @GetMapping(\"/sendSimpleMsg\") public String sendSimpleMsg(@RequestParam String content)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); simpleMsgProducer.send(req); return \"发送成功\"; &#125; &#125; 进行测试，请求3次 3.2、work模式队列常量类RabbitmqConstant，声明常量为队列名称 public class RabbitmqConstant &#123; /** ================ 工作模式 begin ================ */ public static final String LEARN_WORK_QUEUE = \"LEARN.WORK.QUEUE\"; /** ================ 工作模式 end ================ */ &#125; 创建队列配置类WorkRabbitmqConfig，声明创建队列 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class WorkRabbitmqConfig &#123; @Bean(name = RabbitmqConstant.LEARN_WORK_QUEUE) public Queue queue()&#123; return new Queue(RabbitmqConstant.LEARN_WORK_QUEUE, false, false, false); &#125; &#125; 创建此队列的生产者类WorkMsgProducer，提供send方法进行生产消息 package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class WorkMsgProducer &#123; @Autowired private AmqpTemplate amqpTemplate; public void send(SendBaseMsgReq req)&#123; amqpTemplate.convertAndSend(RabbitmqConstant.LEARN_WORK_QUEUE, JSON.toJSONString(req)); &#125; &#125; 创建此队列的消费者类WorkMsgConsumer，监听队列进行消费 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class WorkMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_WORK_QUEUE) public void workMsgConsumerListenerA(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"工作模式消费A：&#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_WORK_QUEUE) public void workMsgConsumerListenerB(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"工作模式消费B：&#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_WORK_QUEUE) public void workMsgConsumerListenerC(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"工作模式消费C：&#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private WorkMsgProducer workMsgProducer; @GetMapping(\"/sendWorkMsg\") public String sendWorkMsg(@RequestParam String content)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); workMsgProducer.send(req); return \"发送成功\"; &#125; &#125; 进行测试，请求6次 可以看到，如果正常消费的情况下，多个消费者会轮循进行消费 3.3、Direct直连模式 在使用Direct之前，我们先得了解rabbitmq的Exchange交换机，这个交换机扮演了什么样的角色，在消息队列中处到了什么样的作用 生产者生产的消息会先到交换机Exchange，再通过router_key和路由策略分发到相对应的队列，再通过消费者监听队列消费消息 以下是官方的图 队列常量类RabbitmqConstant，声明常量为队列名称 public class RabbitmqConstant &#123; /** ================ 直连模式 begin ================ */ public static final String LEARN_DIRECT_QUEUE = \"LEARN.DIRECT.QUEUE\"; public static final String LEARN_DIRECT_EXCHANGE = \"LEARN.DIRECT.EXCHANGE\"; public static final String LEARN_DIRECT_ROUTER_KEY = \"LEARN.DIRECT.ROUTER_KEY\"; /** ================ 直连模式 end ================ */ &#125; 创建队列配置类DirectRabbitmqConfig，声明创建队列，声明创建交换机，将交换机和队列进行绑定 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.Queue; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 直连模式 */ @Configuration public class DirectRabbitmqConfig &#123; @Bean(name = RabbitmqConstant.LEARN_DIRECT_QUEUE) public Queue directQueue()&#123; return new Queue(RabbitmqConstant.LEARN_DIRECT_QUEUE, true); &#125; @Bean(name = RabbitmqConstant.LEARN_DIRECT_EXCHANGE) public DirectExchange directExchange()&#123; return new DirectExchange(RabbitmqConstant.LEARN_DIRECT_EXCHANGE, true, false); &#125; @Bean public Binding bindingDirect(@Qualifier(RabbitmqConstant.LEARN_DIRECT_QUEUE) Queue directQueue, @Qualifier(RabbitmqConstant.LEARN_DIRECT_EXCHANGE) DirectExchange directExchange)&#123; return BindingBuilder.bind(directQueue).to(directExchange).with(RabbitmqConstant.LEARN_DIRECT_ROUTER_KEY); &#125; &#125; 创建此队列的生产者类DirectMsgProducer，提供send方法进行生产消息 package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class DirectMsgProducer &#123; @Autowired private RabbitTemplate rabbitTemplate; public void send(SendBaseMsgReq req)&#123; rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_DIRECT_EXCHANGE, RabbitmqConstant.LEARN_DIRECT_ROUTER_KEY, JSON.toJSONString(req)); &#125; &#125; 创建此队列的消费者类DirectMsgConsumer，监听队列进行消费 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class DirectMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_DIRECT_QUEUE) public void directMsgConsumerListener(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"直连模式消费：&#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_DIRECT_QUEUE) public void newDirectMsgConsumerListener(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"新的消费：直连模式消费：&#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private DirectMsgProducer directMsgProducer; @GetMapping(\"/sendDirectMsg\") public String sendDirectMsg(@RequestParam String content)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); directMsgProducer.send(req); return \"发送成功\"; &#125; &#125; 进行测试，请求4次 在看到一个消费者监听了队列后，我在想，能不能可以使用多个消费者监听同个队列，会造成什么样的结果 修改下消费者类DirectMsgConsumer，使此队列拥有两个消费者 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class DirectMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_DIRECT_QUEUE) public void directMsgConsumerListener(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"直连模式消费：&#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_DIRECT_QUEUE) public void newDirectMsgConsumerListener(String message) &#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"新的消费：直连模式消费：&#123;&#125;\", req.getContent()); &#125; &#125; 再测试，请求4次，查看日志 照样是消费者轮循处理消息的，且不会重复消费 在经过以上的测试，我对于前面写的简单模式和work模式有了一个猜想，会不会==没有指定交换机的这两个模式，本质上就是直连模式==，而交换机使用的默认的交换机名字。 带着这个猜想，我打开了rabbitmq的web管理后台，查看交换机，在简单模式和work模式上再发送几条请求 果然，这个AMQP default交换机有消息进入，证明了我的猜想，为了更加一步的求实，我翻阅了官方文档 – 简单翻译一下 默认交换机 默认交换机是一个由”broker”预先声明好的没有名字（空字符串）的直连交换机。他有一个特殊的属性，这会使得它对于简单的应用程序变得十分有用。创建的每个队列都会使用队列名作为router_key自动绑定到它。 例如，当你声明名称为”search-indexing-online”的队列时，”broker”将使用”search-indexing-online”作为router_key将它绑定到default exchange。因此，一条被发布到default exchange并且routing_key为”search-indexing-online”将被路由到名称为”search-indexing-online”的queue。换句话说，default exchange使直接传送消息到queue成为可能，即使从技术角度上而言，事实并不是这样。 所以，平常程序若是简单，我们可以直接使用默认交换机，这样可以省略少些点代码不是吗 3.4、Fanout扇形模式此类模式，我更习惯称呼为广播模式。因为，交换机上可以绑定多个队列，router_key不生效，默认向绑定的所有队列进行发送消息，就像广播一样。 队列常量类RabbitmqConstant，声明常量为队列名称 public class RabbitmqConstant &#123; /** ================ 扇形模式 begin ================ */ public static final String LEARN_FANOUT_QUEUE_A = \"LEARN.FANOUT.QUEUE.A\"; public static final String LEARN_FANOUT_QUEUE_B = \"LEARN.FANOUT.QUEUE.B\"; public static final String LEARN_FANOUT_QUEUE_C = \"LEARN.FANOUT.QUEUE.C\"; public static final String LEARN_FANOUT_EXCHANGE = \"LEARN.FANOUT.EXCHANGE\"; public static final String LEARN_FANOUT_ROUTER_KEY = \"LEARN.FANOUT.ROUTER_KEY\";// 扇形模式，路由键无用 /** ================ 扇形模式 end ================ */ &#125; 创建队列配置类FanoutRabbitConfig，声明创建队列，声明创建交换机，将交换机和队列进行绑定 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 扇形模式 */ @Configuration public class FanoutRabbitConfig &#123; @Bean(name = RabbitmqConstant.LEARN_FANOUT_QUEUE_A) public Queue queueA()&#123; return new Queue(RabbitmqConstant.LEARN_FANOUT_QUEUE_A, true); &#125; @Bean(name = RabbitmqConstant.LEARN_FANOUT_QUEUE_B) public Queue queueB()&#123; return new Queue(RabbitmqConstant.LEARN_FANOUT_QUEUE_B, true); &#125; @Bean(name = RabbitmqConstant.LEARN_FANOUT_QUEUE_C) public Queue queueC()&#123; return new Queue(RabbitmqConstant.LEARN_FANOUT_QUEUE_C, true); &#125; @Bean(name = RabbitmqConstant.LEARN_FANOUT_EXCHANGE) public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(RabbitmqConstant.LEARN_FANOUT_EXCHANGE, true, false); &#125; @Bean public Binding bindingFanoutQueueA()&#123; return BindingBuilder.bind(queueA()).to(fanoutExchange()); &#125; @Bean public Binding bindingFanoutQueueB()&#123; return BindingBuilder.bind(queueB()).to(fanoutExchange()); &#125; @Bean public Binding bindingFanoutQueueC()&#123; return BindingBuilder.bind(queueC()).to(fanoutExchange()); &#125; &#125; 创建此队列的生产者类FanoutMsgProducer，提供send方法进行生产消息 package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class FanoutMsgProducer &#123; @Autowired private RabbitTemplate rabbitTemplate; public void send(SendBaseMsgReq req)&#123; rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_FANOUT_EXCHANGE, null, JSON.toJSONString(req)); &#125; &#125; 创建此队列的消费者类FanoutMsgConsumer，监听队列进行消费 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class FanoutMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_FANOUT_QUEUE_A) public void fanoutMsgConsumerListenerA(Message message, Channel channel)&#123; SendBaseMsgReq req = JSON.parseObject(message.getBody(), SendBaseMsgReq.class); log.info(\"扇形模式消费A: &#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_FANOUT_QUEUE_B) public void fanoutMsgConsumerListenerB(Message message, Channel channel)&#123; SendBaseMsgReq req = JSON.parseObject(message.getBody(), SendBaseMsgReq.class); log.info(\"扇形模式消费B: &#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_FANOUT_QUEUE_C) public void fanoutMsgConsumerListenerC(Message message, Channel channel)&#123; SendBaseMsgReq req = JSON.parseObject(message.getBody(), SendBaseMsgReq.class); log.info(\"扇形模式消费C: &#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private FanoutMsgProducer fanoutMsgProducer; @GetMapping(\"/sendFanoutMsg\") public String sendFanoutMsg(@RequestParam String content)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); fanoutMsgProducer.send(req); return \"发送成功\"; &#125; &#125; 进行测试，请求2次 3.5、Topic主题模式在主题模式中，路由键的匹配规则将成为重点，符合匹配规则的消息会发送到指定的队列 *：匹配一个单词 #：匹配0-n个单词 交换机与队列绑定的router_key 推送消息的router_key 是否推送到此队列 topic.# topic.A 是 topic.# topic.A.B 是 topic.# A.topic 否 *.topic A.B.topic 否 *.topic A.topic 是 队列常量类RabbitmqConstant，声明常量为队列名称 public class RabbitmqConstant &#123; /** ================ 主题模式 begin ================ */ public static final String LEARN_TOPIC_QUEUE_LOG = \"LEARN.TOPIC.QUEUE.LOG\"; public static final String LEARN_TOPIC_QUEUE_TEXT = \"LEARN.TOPIC.QUEUE.TEXT\"; public static final String LEARN_TOPIC_QUEUE_IMAGE = \"LEARN.TOPIC.QUEUE.IMAGE\"; public static final String LEARN_TOPIC_QUEUE_VOICE = \"LEARN.TOPIC.QUEUE.VOICE\"; public static final String LEARN_TOPIC_EXCHANGE = \"LEARN.TOPIC.EXCHANGE\"; public static final String LEARN_TOPIC_ROUTER_KEY_LOG = \"LEARN.TOPIC.ROUTER_KEY.#\"; public static final String LEARN_TOPIC_ROUTER_KEY_TEXT = \"LEARN.TOPIC.ROUTER_KEY.TEXT\"; public static final String LEARN_TOPIC_ROUTER_KEY_IMAGE = \"LEARN.TOPIC.ROUTER_KEY.IMAGE\"; public static final String LEARN_TOPIC_ROUTER_KEY_VOICE = \"LEARN.TOPIC.ROUTER_KEY.VOICE\"; /** ================ 主题模式 end ================ */ &#125; 创建队列配置类TopicRabbitmqConfig，声明创建队列，声明创建交换机，将交换机和队列进行绑定 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 主题模式 */ @Configuration public class TopicRabbitmqConfig &#123; @Bean(name = RabbitmqConstant.LEARN_TOPIC_QUEUE_LOG) public Queue queueLog()&#123; return new Queue(RabbitmqConstant.LEARN_TOPIC_QUEUE_LOG, true); &#125; @Bean(name = RabbitmqConstant.LEARN_TOPIC_QUEUE_TEXT) public Queue queueText()&#123; return new Queue(RabbitmqConstant.LEARN_TOPIC_QUEUE_TEXT, true); &#125; @Bean(name = RabbitmqConstant.LEARN_TOPIC_QUEUE_IMAGE) public Queue queueImage()&#123; return new Queue(RabbitmqConstant.LEARN_TOPIC_QUEUE_IMAGE, true); &#125; @Bean(name = RabbitmqConstant.LEARN_TOPIC_QUEUE_VOICE) public Queue queueVoice()&#123; return new Queue(RabbitmqConstant.LEARN_TOPIC_QUEUE_VOICE, true); &#125; @Bean(name = RabbitmqConstant.LEARN_TOPIC_EXCHANGE) public TopicExchange topicExchange()&#123; return new TopicExchange(RabbitmqConstant.LEARN_TOPIC_EXCHANGE, true, false); &#125; @Bean public Binding bindingQueueLog(@Qualifier(RabbitmqConstant.LEARN_TOPIC_EXCHANGE) TopicExchange topicExchange)&#123; return BindingBuilder.bind(queueLog()).to(topicExchange).with(RabbitmqConstant.LEARN_TOPIC_ROUTER_KEY_LOG); &#125; @Bean public Binding bindingQueueText(@Qualifier(RabbitmqConstant.LEARN_TOPIC_EXCHANGE) TopicExchange topicExchange)&#123; return BindingBuilder.bind(queueText()).to(topicExchange).with(RabbitmqConstant.LEARN_TOPIC_ROUTER_KEY_TEXT); &#125; @Bean public Binding bindingQueueImage(@Qualifier(RabbitmqConstant.LEARN_TOPIC_EXCHANGE) TopicExchange topicExchange)&#123; return BindingBuilder.bind(queueImage()).to(topicExchange).with(RabbitmqConstant.LEARN_TOPIC_ROUTER_KEY_IMAGE); &#125; @Bean public Binding bindingQueueVoice(@Qualifier(RabbitmqConstant.LEARN_TOPIC_EXCHANGE) TopicExchange topicExchange)&#123; return BindingBuilder.bind(queueVoice()).to(topicExchange).with(RabbitmqConstant.LEARN_TOPIC_ROUTER_KEY_VOICE); &#125; &#125; 创建此队列的生产者类TopicMsgProducer，提供send方法进行生产消息 package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class TopicMsgProducer &#123; @Autowired private RabbitTemplate rabbitTemplate; public void sendText(SendBaseMsgReq req)&#123; rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_TOPIC_EXCHANGE, RabbitmqConstant.LEARN_TOPIC_ROUTER_KEY_TEXT, JSON.toJSONString(req)); &#125; public void sendImage(SendBaseMsgReq req)&#123; rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_TOPIC_EXCHANGE, RabbitmqConstant.LEARN_TOPIC_ROUTER_KEY_IMAGE, JSON.toJSONString(req)); &#125; public void sendVoice(SendBaseMsgReq req)&#123; rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_TOPIC_EXCHANGE, RabbitmqConstant.LEARN_TOPIC_ROUTER_KEY_VOICE, JSON.toJSONString(req)); &#125; &#125; 创建此队列的消费者类TopicConsumer，监听队列进行消费 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.messaging.handler.annotation.Headers; import org.springframework.stereotype.Component; import java.util.Map; @Slf4j @Component public class TopicConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_TOPIC_QUEUE_LOG) public void topicMsgConsumerListenerLog(String message, Channel channel, @Headers Map&lt;String, Object> headerMap)&#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"主题模式消费，日志队列: &#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_TOPIC_QUEUE_TEXT) public void topicMsgConsumerListenerText(String message, Channel channel, @Headers Map&lt;String, Object> headerMap)&#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"主题模式消费，文本队列: &#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_TOPIC_QUEUE_IMAGE) public void topicMsgConsumerListenerImage(String message, Channel channel, @Headers Map&lt;String, Object> headerMap)&#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"主题模式消费，图片队列: &#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_TOPIC_QUEUE_VOICE) public void topicMsgConsumerListenerVoice(String message, Channel channel, @Headers Map&lt;String, Object> headerMap)&#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"主题模式消费，语音队列: &#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private TopicMsgProducer topicMsgProducer; @GetMapping(\"/sendTopicMsg\") public String sendTopicMsg(@RequestParam String content, @RequestParam String type)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); switch (type)&#123; case \"TEXT\": topicMsgProducer.sendText(req); break; case \"IMAGE\": topicMsgProducer.sendImage(req); break; case \"VOICE\": topicMsgProducer.sendVoice(req); break; default: return \"不明确的消息类型，请确认！\"; &#125; return \"发送成功\"; &#125; &#125; 进行测试，TEXT、IMAGE、VOICE各请求两次。可见，日志队列消费了其他所有的消息 3.6、Headers头部交换机header交换机为在多个属性进行路由而设计的，这些属性更容易描述为消息头，而不是routing key。headers交换机忽略routing key属性，相反用于路由的属性是从headers属性中获取的。如果消息头的值等于指定的绑定值，则认为消息是匹配的。 队列常量类RabbitmqConstant，声明常量为队列名称 public class RabbitmqConstant &#123; /** ================ 头部模式 begin ================ */ public static final String LEARN_HEADERS_QUEUE_ANY = \"LEARN.HEADERS.QUEUE.ANY\"; public static final String LEARN_HEADERS_QUEUE_ALL = \"LEARN.HEADERS.QUEUE.ALL\"; public static final String LEARN_HEADERS_EXCHANGE = \"LEARN.HEADERS.EXCHANGE\"; public static final String LEARN_HEADERS_ROUTER_KEY = \"LEARN.HEADERS.ROUTER_KEY\";// 路由键无用，头部模式通过消息头来进行路由 /** ================ 头部模式 end ================ */ &#125; 创建队列配置类HeadersRabbitmqConfig，声明创建队列，声明创建交换机，将交换机和队列进行绑定 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.HeadersExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; /** * 头部模式 */ @Configuration public class HeadersRabbitmqConfig &#123; @Bean(name = RabbitmqConstant.LEARN_HEADERS_QUEUE_ANY) public Queue queueAny()&#123; return new Queue(RabbitmqConstant.LEARN_HEADERS_QUEUE_ANY, false, true, true); &#125; @Bean(name = RabbitmqConstant.LEARN_HEADERS_QUEUE_ALL) public Queue queueAll()&#123; return new Queue(RabbitmqConstant.LEARN_HEADERS_QUEUE_ALL, false, true, true); &#125; @Bean(name = RabbitmqConstant.LEARN_HEADERS_EXCHANGE) public HeadersExchange headersExchange()&#123; return new HeadersExchange(RabbitmqConstant.LEARN_HEADERS_EXCHANGE, false, true); &#125; @Bean public Binding bindingHeadersQueueAny()&#123; HashMap&lt;String, Object> map = new HashMap&lt;>(); map.put(\"name\", \"banmoon\"); return BindingBuilder.bind(queueAny()).to(headersExchange()).whereAny(map).match(); &#125; @Bean public Binding bindingHeadersQueueAll()&#123; HashMap&lt;String, Object> map = new HashMap&lt;>(); map.put(\"name\", \"banmoon\"); map.put(\"sex\", \"男\"); return BindingBuilder.bind(queueAll()).to(headersExchange()).whereAll(map).match(); &#125; &#125; 创建此队列的生产者类HeadersMsgProducer，提供send方法进行生产消息 package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.amqp.core.Message; import org.springframework.amqp.core.MessageProperties; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.util.Map; @Component public class HeadersMsgProducer &#123; @Autowired private RabbitTemplate rabbitTemplate; public void send(SendBaseMsgReq req, Map&lt;String, Object> headerMap)&#123; MessageProperties messageProperties = new MessageProperties(); messageProperties.getHeaders().putAll(headerMap); Message message = new Message(JSON.toJSONBytes(req), messageProperties); rabbitTemplate.send(RabbitmqConstant.LEARN_HEADERS_EXCHANGE, null, message); &#125; &#125; 创建此队列的消费者类HeadersMsgConsumer，监听队列进行消费 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.messaging.handler.annotation.Headers; import org.springframework.stereotype.Component; import java.util.Map; @Slf4j @Component public class HeadersMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_HEADERS_QUEUE_ANY) public void headersMsgConsumerListenerAny(String message, Channel channel, @Headers Map&lt;String, Object> headerMap)&#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"headers模式消费，任一匹配队列: &#123;&#125;\", req.getContent()); &#125; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_HEADERS_QUEUE_ALL) public void headersMsgConsumerListenerAll(String message, Channel channel, @Headers Map&lt;String, Object> headerMap)&#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"headers模式消费，全匹配队列: &#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; import java.util.Map; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private DirectMsgProducer directMsgProducer; @PostMapping(\"/sendHeadersMsg\") public String sendHeadersMsg(@RequestParam String content, @RequestBody Map&lt;String, Object> headersMap)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); headersMsgProducer.send(req, headersMap); return \"发送成功\"; &#125; &#125; 测试三组，各请求1次 第一组：仅进入任一匹配的队列 第二组：两个队列皆进入 第三组：没有进队列 3.7、延迟队列TTL在许多业务场景中，消息需要延迟进行处理，如以下 订单在创建完成后，一小时未支付时通知用户及时支付 订单在创建完成后，24小时未支付后，自动关闭订单 到点秒杀，前15分钟通知用户进行准备 在以上业务中，可以使用定时任务去查询数据库来进行实现，但这样的延迟不精确，且代码极度不优雅。我见过几个工程，里面定时任务一大堆，每天打印的日志起码都在150MB左右。而且，这样的程序会给数据库和服务器带来很大的压力，不是明智的选择。 而现在，rabbitmq可以实现延迟队列，可以解决以上的业务场景 延迟队列TTL（Time To Live）是rabbitmq中的一个高级特性，是==消息或者队列的一个属性==，==此属性的作用是本消息或本队列中的消息最大存活的时间==。如果时间一到，这条消息没有被消费，此消息将会进入死信交换机，再通过对应的路由策略进入队列，进行消费 死信交换机和普通的交换机没有任何区别，可以是任何一种类型，也可以用普通常用的方式进行声明，与队列进行绑定 队列常量类RabbitmqConstant，声明常量为队列名称 public class RabbitmqConstant &#123; /** ================ 延迟队列 begin ================ */ public static final String LEARN_TTL_QUEUE_GLOBAL = \"LEARN.TTL.QUEUE.GLOBAL\";// 将设置队列中的消息最大存活时间 public static final String LEARN_TTL_QUEUE_LOCAL = \"LEARN.TTL.QUEUE.LOCAL\";// 将单独设置消息的过期时间 public static final String LEARN_TTL_EXCHANGE = \"LEARN.TTL.EXCHANGE\"; public static final String LEARN_TTL_ROUTER_KEY_GLOBAL = \"LEARN.DIRECT.ROUTER_KEY.GLOBAL\"; public static final String LEARN_TTL_ROUTER_KEY_LOCAL = \"LEARN.DIRECT.ROUTER_KEY.LOCAL\"; public static final String LEARN_TTL_DEATH_QUEUE = \"LEARN.TTL.DEATH.QUEUE.GLOBAL\";// 死信交换机绑定的队列 public static final String LEARN_TTL_DEATH_EXCHANGE = \"LEARN.TTL.DEATH.EXCHANGE\";// 死信交换机 public static final String LEARN_TTL_DEATH_ROUTER_KEY = \"LEARN.TTL.DEATH.ROUTER_KEY\"; /** ================ 延迟队列 end ================ */ &#125; 创建队列配置类TtlRabbitmqConfig，声明创建队列，声明创建交换机，将交换机和队列进行绑定 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; /** * TTL 延迟队列 */ @Configuration public class TtlRabbitmqConfig &#123; @Bean(name = RabbitmqConstant.LEARN_TTL_QUEUE_GLOBAL) public Queue queueGlobal()&#123; Map&lt;String, Object> arguments = new HashMap&lt;>(); // 有效时间过后转发的死信交换机 arguments.put(\"x-dead-letter-exchange\", RabbitmqConstant.LEARN_TTL_DEATH_EXCHANGE); // 死信交换机绑定队列的routingKey arguments.put(\"x-dead-letter-routing-key\", RabbitmqConstant.LEARN_TTL_DEATH_ROUTER_KEY); // 设置最大存活时间，此处全局设置 arguments.put(\"x-message-ttl\", 7000); Queue queue = QueueBuilder.durable(RabbitmqConstant.LEARN_TTL_QUEUE_GLOBAL) .withArguments(arguments) .build(); return queue; &#125; @Bean(name = RabbitmqConstant.LEARN_TTL_QUEUE_LOCAL) public Queue queueLocal()&#123; Map&lt;String, Object> arguments = new HashMap&lt;>(); // 有效时间过后转发的死信交换机 arguments.put(\"x-dead-letter-exchange\", RabbitmqConstant.LEARN_TTL_DEATH_EXCHANGE); // 死信交换机绑定队列的routingKey arguments.put(\"x-dead-letter-routing-key\", RabbitmqConstant.LEARN_TTL_DEATH_ROUTER_KEY); Queue queue = QueueBuilder.durable(RabbitmqConstant.LEARN_TTL_QUEUE_LOCAL) .withArguments(arguments) .build(); return queue; &#125; @Bean(name = RabbitmqConstant.LEARN_TTL_EXCHANGE) public DirectExchange directExchange()&#123; return new DirectExchange(RabbitmqConstant.LEARN_TTL_EXCHANGE, true, false); &#125; @Bean public Binding bindingQueueGlobal()&#123; return BindingBuilder.bind(queueGlobal()).to(directExchange()).with(RabbitmqConstant.LEARN_TTL_ROUTER_KEY_GLOBAL); &#125; @Bean public Binding bindingQueueLocal()&#123; return BindingBuilder.bind(queueLocal()).to(directExchange()).with(RabbitmqConstant.LEARN_TTL_ROUTER_KEY_LOCAL); &#125; /** ================ 死信队列和交换机 begin ================ */ @Bean(name = RabbitmqConstant.LEARN_TTL_DEATH_QUEUE) public Queue queueDeath()&#123; return new Queue(RabbitmqConstant.LEARN_TTL_DEATH_QUEUE, true); &#125; @Bean(name = RabbitmqConstant.LEARN_TTL_DEATH_EXCHANGE) public DirectExchange deathExchange()&#123; return new DirectExchange(RabbitmqConstant.LEARN_TTL_DEATH_EXCHANGE, true, false); &#125; @Bean public Binding bindingQueueDeath()&#123; return BindingBuilder.bind(queueDeath()).to(deathExchange()).with(RabbitmqConstant.LEARN_TTL_DEATH_ROUTER_KEY); &#125; /** ================ 死信队列和交换机 end ================ */ &#125; 创建此队列的生产者类TtlMsgProducer package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.core.MessageBuilder; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Slf4j @Component public class TtlMsgProducer &#123; @Autowired private RabbitTemplate rabbitTemplate; public void sendGlobal(SendBaseMsgReq req)&#123; log.info(\"发送消息, 设置队列处的最大存活时间，7s：&#123;&#125;\", JSON.toJSONString(req)); rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_TTL_EXCHANGE, RabbitmqConstant.LEARN_TTL_ROUTER_KEY_GLOBAL, JSON.toJSONString(req)); &#125; public void sendLocal(SendBaseMsgReq req, String expiration)&#123; log.info(\"发送消息, 设置消息处的最大存活时间：&#123;&#125;\", JSON.toJSONString(req)); Message message = MessageBuilder .withBody(JSON.toJSONBytes(req)) .setExpiration(expiration) .build(); rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_TTL_EXCHANGE, RabbitmqConstant.LEARN_TTL_ROUTER_KEY_LOCAL, message); &#125; &#125; 创建此队列的消费者类TtlMsgConsumer，监听队列进行消费，==注意这里消费的队列是死信队列，普通队列根本没有消费者进行消费，队列里的消息存活超时后将会进入死信队列== package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class TtlMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_TTL_DEATH_QUEUE) public void ttlMsgConsumerListener(String message)&#123; SendBaseMsgReq req = JSON.parseObject(message, SendBaseMsgReq.class); log.info(\"TTL延迟队列，消费消息: &#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private TtlMsgProducer ttlMsgProducer; @GetMapping(\"/sendTtlMsg\") public String sendTtlMsg(@RequestParam String content, @RequestParam String type, @RequestParam(required = false) String expiration)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); switch (type)&#123; case \"GLOBAL\": ttlMsgProducer.sendGlobal(req); break; case \"LOCAL\": ttlMsgProducer.sendLocal(req, expiration); break; default: return \"不明确的消息类型，请确认！\"; &#125; return \"发送成功\"; &#125; &#125; 进行测试，队列设置和消息设置的各请求一次 查看日志消费，==发送消息打印的日志和消费的日志时间间隔正好是设置的存活时间== 以上的队列可以解决固定的延迟业务场景，可当出现延迟时间不一致的时候，就会出现以下的情况 第一次请求20秒延迟的消息，马上请求第二次3秒的 可以看到，先进队列的20s的延迟消息会卡着3秒的延迟消息，所以TTL的延迟队列只适合相同延迟时间的业务场景那如果是不同时间的消息呢，自然不可能设置多条队列，这时就得用到了TXL延迟队列 3.8、延迟队列TXLTXL延迟队列，主要用到了rabbitmq的一个插件，rabbitmq_delayed_message_exchange 插件的下载地址：https://www.rabbitmq.com/community-plugins.html 下载后将插件放入rabbitmq/plugins目录下 # 查看插件列表 rabbitmq-plugins list # 启用延迟插件 rabbitmq-plugins enable rabbitmq_delayed_message_exchange # 重启rabbitmq 如果顺利的话，插件就会启用成功；如果报错，那就需要检查下erlang运行环境和插件的版本号了。 队列常量类RabbitmqConstant，声明常量为队列名称 public class RabbitmqConstant &#123; /** ================ 延迟队列 begin ================ */ public static final String LEARN_TXL_QUEUE = \"LEARN.TXL.QUEUE\"; public static final String LEARN_TXL_EXCHANGE = \"LEARN.TXL.EXCHANGE\"; public static final String LEARN_TXL_ROUTER_KEY = \"LEARN.TXL.ROUTER_KEY\"; /** ================ 延迟队列 end ================ */ &#125; 创建队列配置类TxlRabbitmqConfig，声明创建队列，声明创建交换机，将交换机和队列进行绑定 package com.banmoon.learn.config; import com.banmoon.learn.constants.RabbitmqConstant; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.CustomExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; @Configuration public class TxlRabbitmqConfig &#123; @Bean(name = RabbitmqConstant.LEARN_TXL_QUEUE) public Queue queue()&#123; return new Queue(RabbitmqConstant.LEARN_TXL_QUEUE, true); &#125; @Bean(name = RabbitmqConstant.LEARN_TXL_EXCHANGE) public CustomExchange customExchange()&#123; Map&lt;String, Object> args = new HashMap&lt;>(); args.put(\"x-delayed-type\", \"direct\");// 设置成直连模式 return new CustomExchange(RabbitmqConstant.LEARN_TXL_EXCHANGE, \"x-delayed-message\", true, false, args); &#125; @Bean public Binding bindingTxlQueue() &#123; return BindingBuilder.bind(queue()).to(customExchange()).with(RabbitmqConstant.LEARN_TXL_ROUTER_KEY).noargs(); &#125; &#125; 创建此队列的生产者类TxlMsgProducer，提供send方法进行生产消息 package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Slf4j @Component public class TxlMsgProducer &#123; @Autowired private RabbitTemplate rabbitTemplate; public void send(SendBaseMsgReq req, Integer delayTime)&#123; log.info(\"发送消息, 延迟时间：&#123;&#125;，消息内容：&#123;&#125;\", delayTime, JSON.toJSONString(req)); rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_TXL_EXCHANGE, RabbitmqConstant.LEARN_TXL_ROUTER_KEY, JSON.toJSONString(req), a -> &#123; a.getMessageProperties().setDelay(delayTime); return a; &#125;); &#125; &#125; 创建此队列的消费者类TxlMsgConsumer，监听队列进行消费 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class TxlMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_TXL_QUEUE) public void txlMsgConsumerListener(Message message, Channel channel)&#123; SendBaseMsgReq req = JSON.parseObject(message.getBody(), SendBaseMsgReq.class); log.info(\"TXL延迟队列，消费消息: &#123;&#125;\", req.getContent()); &#125; &#125; 创建一个控制类TestController，用来测试生产消息 package com.banmoon.learn.controller; import com.banmoon.learn.rabbitmq.producer.*; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class TestController &#123; @Autowired private TxlMsgProducer txlMsgProducer; @GetMapping(\"/sendTxlMsg\") public String sendTxlMsg(@RequestParam String content, @RequestParam Integer delayTime)&#123; SendBaseMsgReq req = new SendBaseMsgReq(); req.setContent(content); txlMsgProducer.send(req, delayTime); return \"发送成功\"; &#125; &#125; 进行测试，第一次请求20秒，第二次请求3秒 查看日志消费的消息，已达到预期的效果 四、Exchange交换机类型在上文中，虽然列出了这么多项类型，但实际上交换机类型仅有4种，分别是 交换机类型 默认预先设定的交换机名字 说明 Direct exchange (Empty string) and amq.direct 直连交换机，如果省略指定交换机，rabbitmq会使用默认的，这可以使开发省下一些时间 Fanout exchange amq.fanout 扇形交换机，在此交换机中，router_key是失效的，消息会转到绑定在该交换机下的所有队列 Topic exchange amq.topic 主题交换机，此交换机可以完成直连交换机和扇形交换机的功能，十分强大当router_key为#时，它便成为了扇形交换机当router_key没有出现*和#时，它便成为了直连交换机 Headers exchange amq.match (and amq.headers in RabbitMQ) 头部交换机，与主题交换机类似，主要区别是此交换机的router_key失效，是通过消息头来进行路由的。此交换机也十分强大，但由于配置比较繁琐，一般项目中都使用主题交换机 五、消息确认机制在使用上，以上的队列使用，已完全满足日常的需求。 在扩展上，消息加入队列，或被消费的时候，使用消息的回调，可以使业务更加丰富。这就是消息的确认机制，分为==生产消息确认==和==消费消息确认==。 5.1、生产消息确认机制有时候，消息发送后没有被消费可能是==没有发送成功==，这时候就出现了生产消息确认。成功失败的消息都会进行回调，我们就可以对其做出进一步的处理。 首先，修改配置文件 server: port: 8011 spring: application: name: rabbitmq_learn rabbitmq: host: 主机名 port: 端口 username: 帐号 password: 密码 # 确认消息是否发送至交换机 publisher-confirm-type: correlated # 确认消息是否发送至队列 publisher-returns: true 本文使用的springBoot版本是2.4.2，旧版本的配置应该将（具体多旧这得翻文档了o(╯□╰)o） # 将 publisher-confirm-type: correlated 改为 publisher-confirms: true 创建RabbitmqConfig，作为生产消息确认的配置 package com.banmoon.learn.config; import com.rabbitmq.client.Channel; import com.rabbitmq.client.ConfirmListener; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.ReturnedMessage; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.io.IOException; @Slf4j @Configuration public class RabbitmqConfig implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback&#123; @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) throws IOException &#123; RabbitTemplate rabbitTemplate = new RabbitTemplate(); rabbitTemplate.setConnectionFactory(connectionFactory); rabbitTemplate.setMandatory(true);// 无论成功失败，都会确认信息 rabbitTemplate.setConfirmCallback(this); rabbitTemplate.setReturnsCallback(this); return rabbitTemplate; &#125; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; if(ack)&#123; log.info(\"【confirm】消息发送成功\"); &#125; else &#123; String id = correlationData==null? null: correlationData.getId(); log.error(\"【confirm】消息发送失败，相关数据：&#123;&#125;，原因：&#123;&#125;\", id, cause); &#125; &#125; @Override public void returnedMessage(ReturnedMessage returnedMessage) &#123; log.info(\"【ReturnCallback】消息：\" + returnedMessage.getMessage()); log.info(\"【ReturnCallback】回应码：\" + returnedMessage.getReplyCode()); log.info(\"【ReturnCallback】回应信息：\" + returnedMessage.getReplyText()); log.info(\"【ReturnCallback】交换机：\" + returnedMessage.getExchange()); log.info(\"【ReturnCallback】路由键：\" + returnedMessage.getRoutingKey()); &#125; &#125; 以上代码已编写完毕，我们再来看看出现的情况种类 以下测试使用直连模式的交换机，创建交换机、队列、绑定的代码我就不贴出来了，大家可以参考3.4进行测试使用，也可以进入我的gitee 生产者代码有些许不同，需要给定相关数据信息，生产者ConfirmMsgProducer package com.banmoon.learn.rabbitmq.producer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class ConfirmMsgProducer &#123; @Autowired private RabbitTemplate rabbitTemplate; public void send(SendBaseMsgReq req)&#123; CorrelationData data = new CorrelationData(JSON.toJSONString(req)); rabbitTemplate.convertAndSend(RabbitmqConstant.LEARN_CONFIRM_EXCHANGE, RabbitmqConstant.LEARN_CONFIRM_ROUTER_KEY, JSON.toJSONString(req), data); &#125; &#125; 本单元仅将生产消息确认，消费者暂时可以不监听指定 1）消息推送，找不到交换机交换机，队列，绑定不用声明，仅留下一个生产者就行 走的confirm方法的回调，在自己输出的同时，上面有串源码中输出的，但进去后没发现confirm方法，没收获什么。 2）消息推送，找到了交换机，但找不到队列交换机，队列可以声明，但不用绑定。这样就算找到了交换机，也找不到队列 可以看到，confirm和returnedMessage的方法都进行了调用 3）消息推送，交换机和队列都没有找到和第一种情况一致，交换机都找不到了，还会去找队列吗？ 4）消息推送成功 仅推送了confirm方法 小结： confirm方法，消息是否到达交换机，无论成功还是失败都会调用 returnedMessage方法，仅当没有找到队列时，才会调用 在上面的示例中，仅打印了日志，在实际的开发中，可以根据自己的业务需求将失败的消息持久化到数据库中，以便排查问题 5.2、消费消息确认机制消息被消费后，我们将进行确认，消息是否被成功消费，这就是消费消息的确认机制。 主要有以下两种 无消息确认：在以上的代码示例中，都是无消费消息的确认，这也是没有指定==默认的消费确认模式== 手动确认：这种机制是最关键的，许多业务都会使用到，消息消费不成功，不符合预期，将会打回队列重新消费 自动确认：消费出现异常就会重发，正常则就消费成功。这种模式有丢失消息的风险，且重复消费可能会阻塞队列，在平常项目中不会经常使用 1）无消息确认在没有消息确认的情况下，只要消息已经进入了消费者，那便立即被认定为消费成功。 所以，无论消费者有没有成功消费消息，还是消费者抛出异常后，消息都会默认处理完毕，也就是丢失了。 那么，在此模式，一定要保证消息是一次性的。异常一定得捕获，打印日志或持久化消息，以便排查问题。 消费者ConfirmMsgConsumer，捕获异常 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component public class ConfirmMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_CONFIRM_QUEUE) public void ConfirmMsgConsumerListener(Message message, Channel channel)&#123; try &#123; SendBaseMsgReq req = JSON.parseObject(message.getBody(), SendBaseMsgReq.class); int a = 1 / 0; log.info(\"消息确认消费：&#123;&#125;\", req.getContent()); &#125; catch (Exception exception) &#123; log.error(\"消息确认消费异常：消息内容：&#123;&#125;\", new String(message.getBody()), exception); &#125; &#125; &#125; 请求测试，发送的消息被捕获后，就再也没有这条消息的影子了 2）手动确认修改下配置文件，添加手动确认的配置 server: port: 8011 spring: application: name: rabbitmq_learn rabbitmq: host: 主机名 port: 端口 username: 帐号 password: 密码 # 确认消息是否发送至交换机 publisher-confirm-type: correlated # 确认消息是否发送至队列 publisher-returns: true listener: simple: # 消费消息确认，none(无)，auto(自动确认)，manual(手动确认) acknowledge-mode: manual # 消费者最小数量 concurrency: 1 # 消费者最大数量 max-concurrency: 1 retry: # 是否支持重试 enabled: true # 最大重试次数，包括第一次消费的次数 max-attempts: 4 # 重试的最大时间间隔 max-interval: 10000 # 重试的初始时间间隔 initial-interval: 2000 # 重试的时间间隔因子 multiplier: 1.5 其中在此模式下，retry的配置是不起作用的，手动进行确认重回队列，具体可查看消费者的代码使用 编写消费者ConfirmMsgConsumer，手动判断重试次数，再进行确认，确认次数可以存到redis缓存 package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import java.io.IOException; import java.util.concurrent.atomic.AtomicInteger; @Slf4j @Component public class ConfirmMsgConsumer &#123; private static AtomicInteger reCount = new AtomicInteger(1); @Value(\"$&#123;spring.rabbitmq.listener.simple.retry.max-attempts&#125;\") private Integer maxReCount; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_CONFIRM_QUEUE) public void ConfirmMsgConsumerListener(Message message, Channel channel) throws IOException &#123; try &#123; SendBaseMsgReq req = JSON.parseObject(message.getBody(), SendBaseMsgReq.class); Integer a = Integer.valueOf(req.getContent()); log.info(\"消息确认消费：&#123;&#125;\", a); channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); reCount.set(1); &#125; catch (Exception exception) &#123; log.error(\"消息确认消费异常：消息内容：&#123;&#125;\", new String(message.getBody())); if(reCount.get()&lt;maxReCount)&#123; reCount.incrementAndGet(); channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true); // channel.basicReject(message.getMessageProperties().getDeliveryTag(), true); return; &#125; reCount.set(1); channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); // channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); &#125; &#125; &#125; 确认消息共有三种 basicAck：肯定确认 deliveryTag：消息的标识ID multiple：是否批量，true为小于deliveryTag的消息也会被确认处理，false为只处理这一条消息 basicNack：否定确认 deliveryTag：同上 multiple：同上 requeue：是否重发队列 basicReject：否定确认，但和basicNack不同的是，basicReject一次只能拒绝单条消息 deliveryTag：同上 requeue：是否重发队列 请求测试，会报异常的请求，可以看到一共消费了4次 请求测试，无异常的请求 在有次项目开发中，需要手动确认的消息，我并没有确认消息的代码，导致消息卡死。 查看后台，明明有消息在准备进行消费了，可就是没有消费，开发的时候好好的，可以正常消费，上测试生产后消费几条后就走不动了，重启工程又有消息进行了消费。 所以，既然选择了手动消费确认的模式，就必须要进行确认，不然就会出现以上诡异的问题。 3）自动确认修改下配置文件，添加手动确认的配置 server: port: 8011 spring: application: name: rabbitmq_learn rabbitmq: host: 主机名 port: 端口 username: 帐号 password: 密码 # 确认消息是否发送至交换机 publisher-confirm-type: correlated # 确认消息是否发送至队列 publisher-returns: true listener: simple: # 消费消息确认，none(无)，auto(自动确认)，manual(手动确认) acknowledge-mode: auto # 消费者最小数量 concurrency: 1 # 消费者最大数量 max-concurrency: 1 retry: # 是否支持重试 enabled: true # 最大重试次数，包括第一次消费的次数 max-attempts: 4 # 重试的最大时间间隔 max-interval: 10000 # 重试的初始时间间隔 initial-interval: 2000 # 重试的时间间隔因子 multiplier: 1.5 编写消费者ConfirmMsgConsumer package com.banmoon.learn.rabbitmq.consumer; import com.alibaba.fastjson.JSON; import com.banmoon.learn.constants.RabbitmqConstant; import com.banmoon.learn.req.SendBaseMsgReq; import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import java.io.IOException; import java.util.concurrent.atomic.AtomicInteger; @Slf4j @Component public class ConfirmMsgConsumer &#123; @RabbitHandler @RabbitListener(queues = RabbitmqConstant.LEARN_CONFIRM_QUEUE) public void ConfirmMsgConsumerListener(Message message, Channel channel) throws IOException &#123; SendBaseMsgReq req = JSON.parseObject(message.getBody(), SendBaseMsgReq.class); log.info(\"消息确认消费：&#123;&#125;\", req.getContent()); Integer a = Integer.valueOf(req.getContent()); &#125; &#125; 请求测试，会报异常的请求 请求测试，正常请求 六、最后在以前，对rabbitmq的使用也是一知半解，通过编写此篇博客，有了许多清晰的了解。 此博客篇幅过长，请耐心观看 如有错误和不解的地方，请在评论区评论 在编写此博客过程中，我查阅了许多博客，也翻阅了官方文档，在此感谢其他博主的博客，给予了我很大的帮助，感谢 小目标青年 弗兰克的猫 rabbitmq官方文档 spring-amqp官方文档","path":"2021/12/02/SpringBoot整合rabbitMq/","date":"12-02","excerpt":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"}]},{"title":"Nginx","text":"什么是NginxNginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。 其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。 Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。 Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。 Nginx作用 Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理 正向代理 正如我们访问GitHub的时候，由于他的服务器在外网而我们是在中国中间隔着一道墙，此时我们去挂一个VPN，就可以正常访问了。 客户端就相当于我们的电脑，然后使用vpn就相当于使用的代理，假如vpn在香港，由于他可以访问外网，此时我们去请求香港的服务器然后他代理我们去请求外网的服务器，返回数据到香港然后香港的服务器再返回给我们。 代理我们客户端的就为正向代理，所以反向代理就为代理服务器的 反向代理 例如百度我们每次访问百度都是访问 《www.baidu.com》 这个域名而他并不是只存放在一台服务器上只是都由一个代理将这些服务器代理了 我们后面的服务器无论动态扩容多少台服务器客户端都没有感知，他只需要访问这一个地址就可以了，这就是反向代理 负载均衡的理解 Nginx提供的负载均衡策略有两种：内置策略和扩展策略，内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不想到没有他做不到 轮询 轮询就是假如我们有三台服务器第一个请求访问第一台服务器，第二次请求访问第二台，第三次请求访问第三台接下来第四次又访问回第一台 加权轮询 假如有一台服务器性能比较好我们就可以给他高一些的权重让他负责更多一些的请求， iphash iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。但是如果服务器挂掉所有的信息就会丢失。所以一般还是用Redis，因为如果服务器挂掉之后session会钝化，等重启之后活化。关于钝化和活化可以访问Session 的钝化与活化。 动静分离动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。 我们先了解到这，在windows和Linux环境下的安装和基本使用以后会说","path":"2021/10/18/Nginx/","date":"10-18","excerpt":"","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"}]},{"title":"整合SSM","text":"整合SSM 环境要求 环境： IDEA MySQL 5.7 Tomcat9 Maven 3.6 要求： 熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis只是，简单的前端知识； 数据库环境 创建一个存放书籍的数据库表 CREATE DATABASE &#96;ssmbuild&#96;; USE &#96;ssmbuild&#96;; DROP TABLE IF EXISTS &#96;books&#96;; CREATE TABLE &#96;books&#96; ( &#96;bookID&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;, &#96;bookName&#96; VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;, &#96;bookCounts&#96; INT(11) NOT NULL COMMENT &#39;数量&#39;, &#96;detail&#96; VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;, KEY &#96;bookID&#96; (&#96;bookID&#96;) ) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8 INSERT INTO &#96;books&#96;(&#96;bookID&#96;,&#96;bookName&#96;,&#96;bookCounts&#96;,&#96;detail&#96;)VALUES (1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;), (2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;), (3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;); 基本环境搭建 1、新建Maven项目ssmbuild,添加web支持 2、导入相关的pom依赖 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;org.zang&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring---mvc&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;packaging&gt;war&lt;&#x2F;packaging&gt; &lt;name&gt;spring---mvc Maven Webapp&lt;&#x2F;name&gt; &lt;!-- FIXME change it to the project&#39;s website --&gt; &lt;url&gt;http:&#x2F;&#x2F;www.example.com&lt;&#x2F;url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;&#x2F;maven.compiler.target&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.47&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt; &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt; &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;1.18.22&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;&#x2F;artifactId&gt; &lt;version&gt;2.11.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.11.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt; &lt;version&gt;2.11.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring---mvc&lt;&#x2F;finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1.0&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;!-- see http:&#x2F;&#x2F;maven.apache.org&#x2F;ref&#x2F;current&#x2F;maven-core&#x2F;default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.0.2&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.8.0&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.22.1&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.2&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5.2&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.8.2&lt;&#x2F;version&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;pluginManagement&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt; &lt;&#x2F;build&gt; &lt;&#x2F;project&gt; 3、Maven资源过滤设置 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt; &lt;&#x2F;build&gt; 4、建立基本结构和配置框架 com.zang.pojo com.zang.dao com.zang.service com.zang.controller mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;/configuration> applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;/beans> MyBatis层编写 1、数据库配置文件database.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://116.62.45.3:3306/ssmbuild?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false jdbc.name=root jdbc.pwd=zangzang 2、编写mybatis核心配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;typeAliases> &lt;package name=\"com.zang.pojo\"/> &lt;/typeAliases> &lt;mappers> &lt;mapper resource=\"com/zang/dao/BookMapper.xml\"/> &lt;/mappers> &lt;/configuration> 3、编写数据库对应的实体类com.zang.pojo.BookS 使用lombok插件 package com.zang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail; &#125; 4、编写Dao层的Mapper接口 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;!--这个用来对应接口--> &lt;mapper namespace=\"com.zang.dao.BookMapper\"> &lt;!--这个用来对接口里边的方法，以及所返回的类型--> &lt;!--增加一个Book--> &lt;insert id=\"addBook\" parameterType=\"Books\"> insert into ssmbuild.books(bookName,bookCounts,detail) values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;) &lt;/insert> &lt;!--根据id删除一个Book--> &lt;delete id=\"deleteBookById\" parameterType=\"int\"> delete from ssmbuild.books where bookID=#&#123;bookID&#125; &lt;/delete> &lt;!--更新Book--> &lt;update id=\"updateBook\" parameterType=\"Books\"> update ssmbuild.books set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125; where bookID = #&#123;bookID&#125; &lt;/update> &lt;!--根据id查询,返回一个Book--> &lt;select id=\"queryBookById\" resultType=\"Books\"> select * from ssmbuild.books where bookID = #&#123;bookID&#125; &lt;/select> &lt;!--查询全部Book--> &lt;select id=\"queryAllBook\" resultType=\"com.zang.pojo.Books\"> SELECT * from books &lt;/select> &lt;/mapper> 6、编写Service层的接口和实现类 接口 package com.zang.service; import com.zang.pojo.Books; import java.util.List; public interface BookService &#123; //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List&lt;Books> queryAllBook(); &#125; 实现类： package com.zang.service; import com.zang.dao.BookMapper; import com.zang.pojo.Books; import java.util.List; public class BookServiceImpl implements BookService&#123; private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) &#123; this.bookMapper = bookMapper; &#125; public int addBook(Books book) &#123; return bookMapper.addBook(book); &#125; public int deleteBookById(int id) &#123; return bookMapper.deleteBookById(id); &#125; public int updateBook(Books books) &#123; return bookMapper.updateBook(books); &#125; public Books queryBookById(int id) &#123; return bookMapper.queryBookById(id); &#125; public List&lt;Books> queryAllBook() &#123; return bookMapper.queryAllBook(); &#125; &#125; 此时底层需求操作编写完毕！ Spring层1、配置Spring整合MyBatis,我们这里使用c3p0连接池 2、我们编写Spring整合MyBatis的相关的配置文件：spring-dao.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 配置整合mybatis --> &lt;!-- 1.关联数据库文件 --> &lt;context:property-placeholder location=\"classpath:database.properties\"/> &lt;!-- 2.数据库连接池 --> &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --> &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;!-- 配置连接池属性 --> &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/> &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/> &lt;property name=\"user\" value=\"$&#123;jdbc.name&#125;\"/> &lt;property name=\"password\" value=\"$&#123;jdbc.pwd&#125;\"/> &lt;!-- c3p0连接池的私有属性 --> &lt;property name=\"maxPoolSize\" value=\"30\"/> &lt;property name=\"minPoolSize\" value=\"10\"/> &lt;!-- 关闭连接后不自动commit --> &lt;property name=\"autoCommitOnClose\" value=\"false\"/> &lt;!-- 获取连接超时时间 --> &lt;property name=\"checkoutTimeout\" value=\"10000\"/> &lt;!-- 当获取连接失败重试次数 --> &lt;property name=\"acquireRetryAttempts\" value=\"2\"/> &lt;/bean> &lt;!-- 3.配置SqlSessionFactory对象 --> &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> &lt;!-- 注入数据库连接池 --> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --> &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/> &lt;/bean> &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --> &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--> &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"> &lt;!-- 注入sqlSessionFactory --> &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/> &lt;!-- 给出需要扫描Dao接口包 --> &lt;property name=\"basePackage\" value=\"com.zang.dao\"/> &lt;/bean> &lt;/beans> 3、Spring整合Service层 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 扫描service相关的bean --> &lt;context:component-scan base-package=\"com.zang.service\" /> &lt;!--BookServiceImpl注入到IOC容器中--> &lt;bean id=\"BookServiceImpl\" class=\"com.zang.service.BookServiceImpl\"> &lt;property name=\"bookMapper\" ref=\"bookMapper\"/> &lt;/bean> &lt;!-- 配置事务管理器 --> &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;!-- 注入数据库连接池 --> &lt;property name=\"dataSource\" ref=\"dataSource\" /> &lt;/bean> &lt;/beans> SpringMVC层1、web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"> &lt;!--DispatcherServlet--> &lt;servlet> &lt;servlet-name>DispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--> &lt;param-value>classpath:applicationContext.xml&lt;/param-value> &lt;/init-param> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>DispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;!--encodingFilter--> &lt;filter> &lt;filter-name>encodingFilter&lt;/filter-name> &lt;filter-class> org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>utf-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>encodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;!--Session过期时间--> &lt;session-config> &lt;session-timeout>15&lt;/session-timeout> &lt;/session-config> &lt;/web-app> 2、spring-mvc.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 配置SpringMVC --> &lt;!-- 1.开启SpringMVC注解驱动 --> &lt;mvc:annotation-driven /> &lt;!-- 2.静态资源默认servlet配置--> &lt;mvc:default-servlet-handler/> &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /> &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /> &lt;property name=\"suffix\" value=\".jsp\" /> &lt;/bean> &lt;!-- 4.扫描web相关的bean --> &lt;context:component-scan base-package=\"com.zang.controller\" /> &lt;/beans> 整合完毕 核心配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;import resource=\"spring-dao.xml\"/> &lt;import resource=\"spring-service.xml\"/> &lt;import resource=\"spring-mvc.xml\"/> &lt;/beans> 将所有的整合到一起 Controller层和页面编写首页&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot; %&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;首页&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; a &#123; text-decoration: none; color: black; font-size: 18px; &#125; h3 &#123; width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h3&gt; &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;allBook&quot;&gt;点击进入列表页&lt;&#x2F;a&gt; &lt;&#x2F;h3&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 信息展示页&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;书籍列表&lt;&#x2F;title&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;&#x2F;small&gt; &lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt; &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toAddBook&quot;&gt;新增&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;table class&#x3D;&quot;table table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;&#x2F;th&gt; &lt;th&gt;书籍名字&lt;&#x2F;th&gt; &lt;th&gt;书籍数量&lt;&#x2F;th&gt; &lt;th&gt;书籍详情&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;c:forEach var&#x3D;&quot;book&quot; items&#x3D;&quot;$&#123;requestScope.get(&#39;list&#39;)&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.getBookID()&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.getBookName()&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.getDetail()&#125;&lt;&#x2F;td&gt; &lt;td&gt; &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toUpdateBook?id&#x3D;$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;&#x2F;a&gt; | &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;del&#x2F;$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; 展现页面Controller编写@RequestMapping(\"/allBook\") public String list(Model model) &#123; List&lt;Books> list = bookService.queryAllBook(); model.addAttribute(\"list\", list); return \"allBook\"; &#125; Controller添加书籍编写@RequestMapping(\"/toAddBook\") public String toAddPaper() &#123; return \"addBook\"; &#125; @RequestMapping(\"/addBook\") public String addPaper(Books books) &#123; System.out.println(books); bookService.addBook(books); return \"redirect:/book/allBook\"; &#125; addBook.jsp编写&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;新增书籍&lt;&#x2F;title&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;&#x2F;small&gt; &lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;addBook&quot; method&#x3D;&quot;post&quot;&gt; 书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;添加&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; Controller更新书籍编写@RequestMapping(\"/toUpdateBook\") public String toUpdateBook(Model model,int id)&#123; Books books = bookService.queryBookById(id); System.out.println(books); model.addAttribute(\"book\",books); return \"updateBook\"; &#125; @RequestMapping(\"/updateBook\") public String updateBook(Model model,Books book)&#123; System.out.println(book); bookService.updateBook(book); Books books = bookService.queryBookById(book.getBookID()); model.addAttribute(\"book\",books); return \"redirect:/book/allBook\"; &#125; updateBook.jsp编写&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt; &lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;修改信息&lt;&#x2F;title&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;修改信息&lt;&#x2F;small&gt; &lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;updateBook&quot; method&#x3D;&quot;post&quot;&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;bookID&quot; value&#x3D;&quot;$&#123;book.getBookID()&#125;&quot;&#x2F;&gt; 书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot; value&#x3D;&quot;$&#123;book.getBookName()&#125;&quot;&#x2F;&gt; 书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot; value&#x3D;&quot;$&#123;book.getBookCounts()&#125;&quot;&#x2F;&gt; 书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot; value&#x3D;&quot;$&#123;book.getDetail() &#125;&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; Controller删除书籍编写@RequestMapping(\"/del/&#123;bookId&#125;\") public String deleteBook(@PathVariable(\"bookId\") int id) &#123; bookService.deleteBookById(id); return \"redirect:/book/allBook\"; &#125; 好了启动tomcat就可以了，此时我们SSM框架就整合完毕了","path":"2021/10/06/整合SSM/","date":"10-06","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"AOP","text":"1、AOP概述AOP(面向切面编程。面向切面编程是从动态角度考虑程序运行过程) 面向切面编程，可通过运行期动态代理实现程序功能的统一维护的一种技术。AOP是Spring框架中的一个重要内容，利用AOP课余对业务的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高了开发的效率 AOP的底层采用了动态代理实现的，采用了JDK的动态代理，与CGLIB的动态代理 面向切面编程，就是将较差业务逻辑封装成切面，利用AOP容器的功能将切面织入到主业务逻辑中，所谓的交叉业务逻辑是指通用的、与主业务逻辑无关的代码如安全检查、事务、日志、缓存等 动态代理​ 实现方式：jdk动态代理，使用jdk中的Proxy，Method，InvocationHander创建代理对象 ​ jdk代理要求，目标类必须实现接口 细节去看我之前发的代理模式 ​ cglib动态代理：第三方的工具类，创建代理对象，原理是继承通过继承目标类创建子类。子类就是代理对象，要求目标类不能是final的方法也不能是final的 ​ 动态代理的作用: 1. 在目标类源代码不改变的情况下，增加功能 2. 减少代码的重复 3. 专注业务逻辑 4. 解耦，让业务功能和非业务功能分离 面向切面的理解 Aspect：切面，给你的目标类增加功能，就是切面，切面的特点，一般都是非业务方法，独立使用 Orient：面向，对着 Programming：编程 怎么理解： 需要分析项目功能时，找出切面 合理的安排切面执行时间，（在目标方法前，还是目标方法后） 合理的安全切面执行的位置，在哪个类，哪个方法增加增强功能 术语Aspect：切面，表示增强的功能，就是一堆代码完成某一个功能。非业务常见的切面功能有日志，事务，统计信息，参数检查，权限验证。 JoinPoint：连接点，连接业务方法和切面的位置，就是某个类中的业务方法 Pointcut：切入点，指多个连接点方法的结合。实际真实被增强的方法 目标对象：给哪个类的方法实现增强功能，这个类就是目标对象 Advice：通知，表示切面功能实现的时间 怎么理解面向切面编程？ 需要在分析项目功能时，找出切面 合理的安排切面的执行时间（在目标方法前还是目标方法后） 合理安排切面执行的位置，在哪个类，那个方法增强功能 面试常问 说一下切面的关键要素 切面的功能代码，切面干什么 切面的执行位置，使用Pointcut表示切面执行的位置 切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后 学习aspectJ框架使用 切面的执行时间，这个执行时间在规范中叫做Advice（通知，增强）在aspectj框架使用注解表示的。也可以使用注解表示，也可以配置到xml文件中 @Befor @After @AfterReturning @AfterThrowing @Around AspectJ切入点表达式（重点） AspectJ定义了专门的表达式用于指定切入点。表达式的原型是： excution(modifiers-pattern ? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throw-pattern?) 解释 modifiers-pattern 访问权限类型 ret-type-pattern 返回值类型 declaring-type-pattern 包类型名 name-pattern(param-pattern) 方法名（参数类型和参数个数） throw-pattern 抛出异常类型 ？表示可选的部分 以上表达式共四个部分 execution（访问权限 方法返回值 方法声明(参数) 异常类型） ​ 切入点表达式要匹配的对象就是目标方法的方法名。所以，execution表达式中明显就是方法的签名。注意，表达式中黑色文字表述可省略部分，各部分间空格分开，在其中可以使用 举例 execution(public * *(..)) 指定切入点为：任意公共方法 execution(* set*(..)) 指定切入点为：任意一个以set开始的方法 execution(* com.xyz.service.*. *(..)) 指定切入点为：定义在service包里的任意类的任意方法 execution(* com.xyz.service..*. * (..)) 指定切入点为：指定所以包下的service包或者子包里的任意类的任意方法 execution(* ..service. * .(..)) 指定所以包下的service子包下的所有类（接口）中所有方法为切入点 案例以及说明1、创建Maven项目导入依赖&lt;dependency> &lt;!--spring依赖--> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>5.2.0.RELEASE&lt;/version> &lt;/dependency> &lt;!--测试类依赖--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> &lt;!--aspectJ依赖--> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjweaver&lt;/artifactId> &lt;version>1.9.4&lt;/version> &lt;/dependency> 2、创建接口和真实对象 3、创建切面类package com.zang.config; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; /** * @Aspect :是aspectj框架中的注解 * 作用：表示当前类是切面类 * 切面类：是用来给业务方法增加功能的类，在这个类中有切面功能的代码 * 位置：在类定义之上 */ @Aspect public class AnnotationPointcut &#123; /** * 定义方法，方法是实现切面功能的 * 方法定义的要求： * 1. 公共方法public * 2. 方法没有返回值 * 3. 方法名称自定义 * 4.方法可以有参数也可以没有参数 * 如果有参数，参数不是自定义的，有几个参数类型可以使用 */ /** * @Before: 前置注解 * 属性value，是切入点表达式，表示切面的功能执行在方法的位置 * * 特点： * 1. 在目标方法之前先执行的 * 2. 不会改变目标方法的执行结果 * 3. 不会影响目标方法的执行 */ @Before(\"execution(* com.zang.service.LoginServiceImpl.loginUser(..))\") public void before()&#123; //你切面要执行的功能代码 System.out.println(\"方法执行前进行切入执行成功\"); &#125; &#125; 4、创建配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;!--把对象交给Spring容器，由spring容器统一创建，管理对象--> &lt;!--声明目标对象--> &lt;bean id=\"loginservice\" class=\"com.zang.service.LoginServiceImpl\"/> &lt;!--声明切面类对象--> &lt;bean id=\"pointcut\" class=\"com.zang.config.AnnotationPointcut\"/> &lt;!--声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象 创建代理对象是在内存中实现的，修改目标对象在内存中的结构，创建为代理对象 所以真实对象就是被修改后的代理对象 aspectj-autoproxy:会把spring容器中的所有真实对象，一次性都生成代理对象 --> &lt;aop:aspectj-autoproxy/> &lt;/beans> 5、创建测试类进行测试","path":"2021/09/18/AOP/","date":"09-18","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"http://example.com/tags/Spring5/"}]},{"title":"聊一聊类加载器","text":"类加载器关于JDK中自带的类加载器 专门负责加载类的命令 JDK中自带了三个类加载器 启动加载器 扩展加载器 应用加载器 /* * 假如有这样一串代码 String name=\"臧臧\" * 代码在开始执行之前会将需要的类全部加载到JVM中， * 通过类加载器加载，看到以上代码之后类加载器会找String.class文件找到就加载 * 1. 首先通过类加载器进行加载 * 1.1 启动类加载器专门加载C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\rt.jar rt.jar中都是JDK最核心的类库 * 2. 通过启动类加载器加载不到的时候 * 会通过扩展类加载器加载C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext.jar * 3. 如果扩展类加载不到的话那么会通过应用加载类加载 * 注意此时扩展类加载的是classpath（梦开始的地方） * * * */ 双亲委派机制java中为了保证类加载的安全，使用了双亲委派机制 优先从启动类加载器中加载，这个成为“父”,当“父类”加载不到的时候再从扩展类加载器中加载，这个成为”母“，双亲委派，如果都加载不到才会考虑从应用类加载器中加载,直到加载到为止 就是假如我们自己写了一个String但是黑客在里边植入了一个病毒，恰巧我们使用了他，如果没有双亲委派机制的话类加载顺序混乱了恰巧加载到了我们自己的类没有加载到Sun公司的String，我们此时就被植入病毒了，所以需要双亲委派机制","path":"2021/09/15/聊一聊类加载器/","date":"09-15","excerpt":"","tags":[{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"代理模式","text":"因为AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 静态代理静态代理角色分析 抽象角色：一般使用接口或者抽象类来实现 真实角色：被代理的角色 代理角色：代理真实角色；代理真实角色后，一般会做一些附属的操作 客户：使用代理角色来进行一些操作 代码实现 Rent.java即抽象角色 package com.zang.dao; public interface Rent &#123; public void rent(); &#125; Host.java真实角色 package com.zang.dao; //真实角色房东，房东要出租房子 public class Host implements Rent &#123; @Override public void rent() &#123; System.out.println(\"房屋出租\"); &#125; &#125; Proxy.java即代理角色 package com.zang.dao; //代理对象，中介 public class Proxy implements Rent &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host=host; &#125; @Override public void rent() &#123; seeHouse(); host.rent(); buy(); &#125; public void seeHouse()&#123; System.out.println(\"看房子\"); &#125; public void buy()&#123; System.out.println(\"买房子\"); &#125; &#125; Client.java客户 public class Client &#123; public static void main(String[] args) &#123; Host host = new Host(); Proxy proxy = new Proxy(host); proxy.rent(); &#125; &#125; 分析： 在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧 租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更 加抽象的看待生活中发生的事情。 静态代理的好处 可以是我们的真实角色更加纯粹不再去关注一些公共的事情 公共的业务由代理来完成，实现了业务的分工， 公司业务发生扩展时变得更加集中和方便 缺点： 类多了，多了代理类，工作量大了，开发效率降低 我们想要静态代理的好处，又不想要静态代理的缺点，所以就有了动态代理！ 静态代理再理解 创建一个抽象角色，比如咱们平时做的用户业务，抽象起来就是增删改查 package com.zang.service; public interface UserService &#123; void addUser(); void deleteUser(); void updateUser(); void query(); &#125; 我们需要一个真实对象来完成这些增删改查操作 package com.zang.service; public class UserServiceImpl implements UserService&#123; @Override public void addUser() &#123; System.out.println(\"添加一个用户\"); &#125; @Override public void deleteUser() &#123; System.out.println(\"删除一个用户\"); &#125; @Override public void updateUser() &#123; System.out.println(\"更新一个用户\"); &#125; @Override public void query() &#123; System.out.println(\"查询一个用户\"); &#125; &#125; 需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1：在实现类上增加代码【麻烦】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的 设置一个代理类来处理日志！代理角色 package com.zang.service; public class Proxy implements UserService&#123; private UserServiceImpl userService; public Proxy(UserServiceImpl userService) &#123; this.userService = userService; &#125; @Override public void addUser() &#123; log(\"add\"); userService.addUser(); &#125; @Override public void deleteUser() &#123; log(\"delete\"); userService.deleteUser(); &#125; @Override public void updateUser() &#123; log(\"update\"); userService.updateUser(); &#125; @Override public void query() &#123; log(\"query\"); userService.query(); &#125; public void log(String msg)&#123; System.out.println(\"执行了\"+msg+\"方法\"); &#125; &#125; 测试访问类 @Test public void testOne()&#123; UserServiceImpl userService = new UserServiceImpl(); Proxy proxy = new Proxy(userService); proxy.addUser(); &#125; ==我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想== 动态代理 动态代理的角色和静态代理的一样 动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的 动态代理分为两类：一类是基于接口的动态代理，一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！ 反射机制复习请搜索文章回顾反射 JDK动态代理 反射：Method类，表示方法，类中的方法，通过Method可以执行某个方法 jdk动态代理的实现 反射包 java.lang.reflect 里面有三个类：invocationHandler，Method，Proxy 1）InvocationHander接口（调用处理器）：就一个方法invoke() ​ invoke()：表示代理对象要执行的功能代码，你的代理类要完成的功能就卸载invoke()方法中， public Object invoke(Object proxy,Method method,Object[] args) ​ Object proxy:jdk创建的代理对象，无需赋值 ​ Method method:目标类中的方法，执行目标方法的功能 ​ Object[] args:目标类中的方法参数 InvocationHander 接口：表示你的代理要干什么 ​ 怎么用：创建类实现接口InvocationHander ​ 重写invoke()方法，把原来静态代理中代理类要完成的功能，写在这 ​ 2）Method类：表示方法的，可以说就是目标类中的方法。 ​ 作用：通过Method可以执行某个目标类中的方法Method.invoke()； ​ Method.invoke(对象,方法的参数) ​ 3）Proxy类：核心的对象，创建代理对象，之前创建对象都是new类的构造方法() ​ 我们使用Proxy类中的方法代替new对象 newProxyInstance()作用是创建代理对象 ​ public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) ​ 参数： 1. ClassLoader loader 类加载器，负责向内存中加载对象的，使用反射获取 2. Class&lt;?&gt; [] interfaces:接口，目标对象实现的类加载器 3. InvocationHander h； 实现动态代理的步骤 创建接口，定义目标类要完成的事 public interface UsbSell &#123; float sell(int amont); &#125; 创建目标类实现接口 //真人 public class UsbSellImpl implements UsbSell &#123; @Override public float sell(int amont) &#123; //目标方法 System.out.println(\"目标类执行了目标方法\"); return amont; &#125; &#125; 创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能 调用目标方法 增强功能 使用Proxy类的静态方法，创建代理对象，并把返回值转为接口类型","path":"2021/09/12/代理模式/","date":"09-12","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"http://example.com/tags/Spring5/"}]},{"title":"Cookie和Session详解","text":"Cookie会话会话：假如我打开了一个浏览器点击了很多链接，访问了多个web资源，然后我不想看的时候关闭了浏览器，这个过程就叫做会话。 有状态会话：这个有状态会话简单来说就是，你在班里很出色，然后你来了班里大家对你印象很深都知道你来过了，你下次再来的时候大家都知道你曾经来过，这个称之为有状态会话 假如你被学校录取了你怎么才能证明你被录取了？ 有两种方式 ​ 录取通知书 ​ 学校官网存档 那么cookie就是第一种方式，就是假如我被沧州师范录取了，学校不给发通知书，只能自己去学校拿然后去学校拿通知书的时候就相当于我是客户端学校是服务端。我第一次访问的时候学校给了我一个cookie，其中有两个参数(key为我的名字)(value为沧州师范),然后等我下次去的时候我带着cookie去就可以了 session就是第二种我去了学校把我的信息全部录进了电脑里然后下次我去的时候让服务端去匹配我。 保存会话的两种技术 cookie 客户端技术(响应，请求) session 服务器技术，利用这个技术，可以保存用户的会话信息 我们可以把信息或者数据放在Session 中！ 常见现象：网站登录之后，你下次再访问就不用登录了，第二次访问就直接自动登陆上去了 cookie Cookie[] cookies = req.getCookies();//客户端获得cookie cookie.getName();//获得cookie中的key cookie.getValue();//获得cookie中的value Cookie cookie = new Cookie(\"key\",\"value\");//新建一个cookie resq.addCookie(cookie);//响应给客户端一个cookie cookie.setMaxAge(24*60*60);//设置cookie有效期 细节问题 一个网站cookie是否存在上限 一个cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie； cookie大小有限制4kb； 300个cookie浏览器上限 删除cookie 不设置有效期，关闭浏览器自动失效 设置有效期为0.(这种方法效率高) 编码与解码 URLEncoder.encode(“臧臧”,”utf-8”) 编码 URLDecoder.decode(cookie.getValue(),”UTF-8”) 解码 Session 什么是Session： ​ 服务器会给每个用户创建一个Session对象 ​ 一个Session单独占一个浏览器，只要浏览器没有关闭这个Session就存在 用户登录之后整个网站他都可以访问(意思就是你登录的你b站首页，然后去b站商城啥的都不用重新登录了) Session和Cookie的区别 - Cookie是把用户的数据写到浏览器中，浏览器保存而且可以保存多个 - Session是把用户的数据写到用户独占的Session中服务端保存(保存重要的信息，减少对资源的浪费) - Session对象是由服务器创建的 使用Session protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); HttpSession session = req.getSession();//获取session session.setAttribute(\"name\", new Pserson(\"臧臧\",20));//保存session对象 &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); HttpSession session = req.getSession(); Pserson name = (Pserson) session.getAttribute(\"name\");//获得session对象 System.out.println(name.getName()+\"现在\"+name.getAge()); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; 会话自动过期 &lt;!--设置Session默认的失效时间--> &lt;session-config> &lt;!--15分钟后Session自动失效，以分钟为单位--> &lt;session-timeout>15&lt;/session-timeout> &lt;/session-config>","path":"2021/08/08/Cookie和Session详解/","date":"08-08","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"http://example.com/tags/javaweb/"}]},{"title":"关于博客基于leancloud实现留言板和评论功能","text":"Valine 评论系统我使用的是这个，因为，我想让我的网站拥有一套评论系统。 ps: 注册 leancloud 国际版，不要使用国内版本。 使用 Valine 评论系统，这款系统不需要登录便可以留言，没有后端，Next 主题最新已经支持安装 基于 Leancloud 的系统 支持 MarkDown 语法 无后端实现，快速高效 配置 首先要注册Leancloud，登录官网然后进行注册，注册成功之后要验证邮箱然后创建应用，选择开发版，创建之后会自动生成App ID和App Key 对其进行配置 2.1 首先进入其主题配置文档_config.yml文件然后修改关于valine的配置 valine: enable: true # 是否开启 appid: # 上一步获取的 App ID appkey: # 上一步获取的 App Key notify: false # 新留言是否需要通知 https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: mm # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 # pagination size #默认单页的留言条数 重新部署 评论管理如果想要管理评论，进入 leancloud 官网，找到 控制台-&gt;存储-&gt;结构化数据-&gt;Comment 中进行管理 有的人想要评论后，邮箱通知，可以使用 Valine-Admin 安全中心在 leancloud 设置 -&gt; 安全中心 ，把 文件上传、短信服务、推送服务、实时通信 这几个服务全部关闭，因为用不到。然后需要特别注意的就是 Web 安全域名 这一个选项，里面一定要填写自己站点的域名，并且带上端口号，例如 http 请求的默认端口就是 80，https 请求的默认端口就是 443。这里如果没有配置好，评论的时候也会失败的","path":"2021/08/05/关于博客基于leancloud实现留言板和评论功能/","date":"08-05","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"algolia搜索功能部署","text":"关于Hexo博客使用algolia进行搜索功能安装部署我在这个过程中遇到很多问题为了防止更多小伙伴跳坑在此写一个教程 首先要前往Algolia官网进行注册，注册一个新用户。可以使用GitHub或者Google账户直接登录 注册完成后创建一个新的Index以备后面使用 接下来要按照Hexo Algolia扩展，这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装： npm install --save hexo-algolia 新建一个API Key 然后 这个ACL里边根据需求添加功能，我是为了以防万一都添加了 在站点根目录下的_config.yml文件中新增以下配置 algolia: applicationID: &#39;你的applicationID&#39; apiKey: &#39;你刚刚创建的apikey&#39; adminApiKey: &#39;你的adminapikey&#39; indexName: &#39;index的名字&#39; chunkSize: 5000 之后在博客根目录右击git bash export HEXO_ALGOLIA_INDEXING_KEY&#x3D;&#39;你刚刚新创建的APIKEY&#39; hexo algolia 修改主题内的_config.yml 启动即可 hexo s","path":"2021/08/02/algolia搜索功能部署/","date":"08-02","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"多态的自我理解","text":"Java多态有多种表现形式 普通类的多态 抽象类的多态 接口的多态 ==但是必须要存在继承关系==有自上而下转型或者自下而上转型，而自下而上转型是自动的比如我们创建一个父亲类然后两个子类，一个儿子类一个女儿类，儿子类和女儿类同时继承的父类的eat方法，而儿子类存在自己单独的跑步方法。 package ManyT; public class Test &#123; public static void main(String[] args) &#123; Father father = new Son(); Father father1 = new Daughter(); Son son =(Son) new Father(); father.eat(); father1.eat(); son.run(); &#125; &#125; class Father &#123; void eat()&#123; System.out.println(\"父亲吃肉\"); &#125; &#125; class Son extends Father&#123; @Override void eat() &#123; System.out.println(\"儿子吃白菜\"); &#125; void run()&#123; System.out.println(\"儿子再跑\"); &#125; &#125; class Daughter extends Father&#123; @Override void eat() &#123; System.out.println(\"女儿吃萝卜\"); &#125; &#125; 自下向上转型首先定义方法为 父类类型 [父类变量名] = new 子类类型(); 此时这个父类变量名字可以调用子类的方法。 ==注意：如果父类中的方法是静态的(static)，子类中的同名方法也是静态的(static)，多态调用的依然是父类的成员方法。原因：静态属于类，不属于对象；多态性是针对对象而言的，和静态无关。所以用父类的引用 调用静态方法必然是执行父类的方法。）== Father father = new Son(); father.eat(); 此时输出儿子在吃 自上向下转型定义方法为 子类类型 [子类变量名] = ==(子类类型)== new 父类类型(); 此时可以调用该子类单独的方法 Son son = (Son) new Father(); son.run(); 此时调用son独有的方法输出儿子在跑。","path":"2021/08/02/多态的自我理解/","date":"08-02","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"静态代理模式简单理解","text":"Java23种设计模式之一静态代理 首先我们要明白为什么要学习静态代理，因为在spring中的AOP底层就是动态代理，而我们只有明白了静态代理和反射的原理之后才能真正的明白动态代理，这篇文章就先为大家讲解一下静态代理。 静态代理是什么东西呢简单来说就是我们的真实角色更加纯粹了，不需要去关注一些公共的事情了 公司的业务由代理来完成，实现了业务的分工 例一 写一个简单实例结婚为例 抽象方法:结婚public interface information &#123; //结婚 void marry(); &#125; 真实对象：主角public class Protagonist implements information&#123; @Override public void marry() &#123; System.out.println(\"结婚人进行结婚\"); &#125; &#125; 代理对象：婚庆公司public class WeddingCompany implements information&#123; private Protagonist proxy; //这里我们使用有参构造 public WeddingCompany(Protagonist proxy) &#123; this.proxy = proxy; &#125; public void marry() &#123; //代理对象进行业务扩展 proxy.marry(); System.out.println(\"婚庆公司布置现场\"); &#125; &#125; 测试 ================================================================================ - 一般你需要用你的王者号登陆打排位上分以及领奖励，但是静态代理就是，你把你的号给了一个代练，代练知道你的账号密码然后给你打排位领奖励就是这个意思 抽象方法public interface information &#123; //登录 void loading(); &#125; 真实角色public class Boss implements information&#123; @Override public void loading() &#123; System.out.println(\"老板登录账号密码\"); &#125; &#125; 代理对象public class BlackSlaves implements information&#123; private Boss proxy; //两种方法set和有参 public void setProxy(Boss proxy) &#123; this.proxy = proxy; &#125; /* * public BlackSlaves(Boss proxy) &#123; * this.proxy = proxy; *&#125; * * */ public void loading() &#123; //代理对象进行业务扩展 proxy.loading(); System.out.println(\"黑奴打排位领奖励\"); &#125; &#125; 进行测试 代理对象可以做很多真实对象做不了的事情真实对象只需要做自己该做的事情就行","path":"2021/08/02/静态代理模式简单理解/","date":"08-02","excerpt":"","tags":[{"name":"代理模式","slug":"代理模式","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]}],"categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Nginx","slug":"Nginx","permalink":"http://example.com/tags/Nginx/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"},{"name":"Spring5","slug":"Spring5","permalink":"http://example.com/tags/Spring5/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"javaweb","slug":"javaweb","permalink":"http://example.com/tags/javaweb/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"代理模式","slug":"代理模式","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]}