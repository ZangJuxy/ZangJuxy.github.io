{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://zangblog.gitee.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"10-30","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"09-14","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"09-14","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"10-30","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"09-14","excerpt":""},{"title":"friends","text":"","path":"friends/index.html","date":"06-17","excerpt":""}],"posts":[{"title":"search","text":"","path":"2021/10/30/search/","date":"10-30","excerpt":"","tags":[]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2021/10/30/hello-world/","date":"10-30","excerpt":"","tags":[]},{"title":"从头开始的一个小项目-4员工列表实现","text":"RestFul风格 我们需要使用RestFul风格实现我们的crud操作 看看一些具体的要求，就是我们小实验的架构 我们根据这一要求，来完成第一个功能，就是我们的员工列表功能! 1、员工列表页面跳转我们在主页点击Customers，就系那是列表页面；我们去修改下 1、将首页的侧边栏Customers改为员工管理2、a链接添加请求1&lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/emps&#125;&quot;&gt; 3、将list放在emp文件下 4、编写处理请求的controller1234567@RequestMapping(&quot;/emps&quot;)public String list(Model model)&#123; List&lt;User&gt; user = userService.getUser(); model.addAttribute(&quot;emps&quot;,user); return &quot;emp/list&quot;;&#125; 我们启动项目，测试一下看是否能够跳转，测试OK！我们只需要将数据渲染进去！即可！ 但是发现了一个问题，侧边栏和顶部都相同，我们是不是应该将它抽取出来呢？ 2、Thymeleaf公共页面元素抽取步骤： ​ 1、抽取公共片段th:fragment定义模板名 ​ 2、引入公共片段th:insert插入模板名 实现： 1、我们来抽取一下，使用list列表做演示！我们要抽取头部nav标签，我们在dashboard中将nav部分定 义一个模板名；","path":"2021/10/29/从头开始的一个小项目-4员工列表实现/","date":"10-29","excerpt":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zangblog.gitee.io/tags/SpringBoot/"}]},{"title":"MyBatis-Plus CRUD扩展","text":"Insert1234567891011@ResponseBody@RequestMapping(&quot;/bb&quot;)public void insertTest()&#123; User user = new User(); user.setAge(18); user.setName(&quot;zz&quot;); user.setEmail(&quot;2556450572@qq.com&quot;); int insert = schemaMapper.insert(user);//会帮我们自动生成id System.out.println(insert); //显示行数 System.out.println(user);//通过日志发现id会自动回填&#125; 数据库插入的id的默认值为:全局的唯—id 主键生成策略源码解释 默认 : ID_WORKER 全局唯一Id 分布式系统唯一Id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html Twitter的snowflake算法 snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心（北京、香港···），5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。 具体实现的代码可以参看https://github.com/twitter/snowflake。 主键自增：AUTO 我们需要配置主键自增 我们需要配置主键自增 在实体类字段上配置@TableId(type = IdType.AUTO) 数据库字段一定是自增 Update123456789101112@ResponseBody@RequestMapping(&quot;/cc&quot;)public void updateTest()&#123; User user = new User(); user.setId(1L); user.setAge(18); user.setName(&quot;zz&quot;); user.setEmail(&quot;2556450572@qq.com&quot;); int i = schemaMapper.updateById(user); //通过条件自动拼接动态sql System.out.println(i);&#125; 自动填充创建时间、更改时间！这些操作一般都是自动化完成，我们不希望手动更新 阿里巴巴开发手册︰几乎所有的表都要配置 gmt_create、gmt_modified ！而且需要自动化 方式一:数据库级别(工作中不允许修改数据库级别)1、在表中增加字段：create_time,update_time 2、再次测试插入或者更新方法，我们需要在实体类中同步 12private Date createTime;//驼峰命名private Date updateTime; 3、查看结果 不建议使用数据库级别的方式 方式二：代码级别1、删除数据库的默认值，更新操作 2、实体类字段属性上需要增加注解 12345//字段 字段添加填充内容@TableField(fill = FieldFill.INSERT)//value = (&quot;create_time&quot;),private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 3、编写处理器来处理这个注解即可！ 123456789101112131415161718192021222324package com.example.demo.Handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;==start insert ······==&quot;); this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;==start update ······==&quot;); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125;&#125; 4、测试插入/更新，观察时间 1234567891011@ResponseBody@RequestMapping(&quot;/bb&quot;)public void insertTest()&#123; User user = new User(); user.setAge(18); user.setName(&quot;zz&quot;); user.setEmail(&quot;2556450572@qq.com&quot;); int insert = schemaMapper.insert(user);//会帮我们自动生成id System.out.println(insert); //显示行数 System.out.println(user);//通过日志发现id会自动回填&#125; 乐观锁在面试过程中，我们经常会被问到乐观锁悲观锁！其实这个特别简单 乐观锁：顾名思义十分乐观，他总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试。 悲观锁：顾名思义十分悲观，他总是认为总出现问题，无论干什么都会上锁！再去操作！ 当要更新一条记录的时候，希望这条记录没有被别人更新 乐观锁实现方式： 取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 12345678乐观锁：1、先查询：获得版本号 version = 1--Aupdate user set name=&quot;zangzang&quot; ,version = version+1where id=1 and version=1--B 线程B抢先完成，这个时候version = 2 ，会导致A修改失败!update user set name=&quot;zangzang&quot; ,version = version+1where id=1 and version=1 测试一下Mybatis-Plus的乐观锁插件 1、给数据库中增加version字段 2、实体类加对应的字段 12@Version//乐观锁的注解private Integer version; 3、注册组件 1234567891011121314151617181920212223242526package config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;@Configuration@EnableTransactionManagementpublic class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); //乐观锁插件 mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mybatisPlusInterceptor; &#125;&#125; 4、测试 12345678910111213141516171819202122//模拟多线程去进行乐观锁失败模拟 @ResponseBody @RequestMapping(&quot;/ee&quot;) public void test()&#123; //线程1 User user = schemaMapper.selectById(1L); user.setName(&quot;zsl&quot;); user.setEmail(&quot;2556450572@qq.com&quot;); user.setAge(10); //B线程进行插入 User userOne = schemaMapper.selectById(1L); userOne.setAge(9); userOne.setEmail(&quot;zangzang@qq.com&quot;); userOne.setName(&quot;zzz&quot;); schemaMapper.updateById(userOne); schemaMapper.updateById(user); /* * 此时userOne更新时会将vision进行+1 * 然后user进行更新时无法匹配vision所以无法将前边数据覆盖 * */&#125; Select 通过id查询单个用户 123456 @ResponseBody @RequestMapping(&quot;/ff&quot;) public User testSelectUserById()&#123; User user = schemaMapper.selectById(1L); return user;&#125; 通过id查询多个用户 123456@ResponseBody @RequestMapping(&quot;/gg&quot;) public List&lt;User&gt; testSelectBatchIds()&#123; List&lt;User&gt; users = schemaMapper.selectBatchIds(Arrays.asList(1L, 2L, 3L)); return users; &#125; 条件查询 通过map封装 123456789@ResponseBody @RequestMapping(&quot;/hh&quot;) public List&lt;User&gt; testMap()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;zz&quot;); map.put(&quot;age&quot;,18); List&lt;User&gt; users = schemaMapper.selectByMap(map); return users; &#125;","path":"2021/10/26/MyBatis-Plus-CRUD扩展/","date":"10-26","excerpt":"","tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://zangblog.gitee.io/tags/MyBatis-Plus/"}]},{"title":"MyBatis-Plus快速入门体验及配置日志输出","text":"Mybatis-Plus 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作，BaseMapper 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求，以后简单的CRUD操作，不用自己编写了 ！ 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（自动帮你生成代码） 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 快速入门官方链接： *https://baomidou.com/guide/\\* 导入Pom配置文件12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;!--1.数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--2.lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--3.mybatis-plus 版本很重要3.0.5--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--4.h2--&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 连接数据库配置 由于我是连接的我的远程服务器数据库，ip地址就不透露了，一般本机都为localhost #mysql5~8 驱动不同driver-class-name 8需要增加时区的配置serverTimezone=UTC #useSSL=false 安全连接 编写实体类1234567891011121314package com.example.demo.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 编写实体类对应的mapper接口12345678910package com.example.demo.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.demo.pojo.User;import org.apache.ibatis.annotations.Mapper;@Mapper//代表持久层public interface SchemaMapper extends BaseMapper&lt;User&gt; &#123; //所有CRUD操作都编写完成了，不用像以前一样配置一大堆文件&#125; 由于只是简单测试一下就不写service层了视图层进行测试返回一个json对象1234567891011121314151617181920package com.example.demo.test;import com.example.demo.mapper.SchemaMapper;import com.example.demo.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class TestPlus &#123; @Autowired private SchemaMapper schemaMapper; @ResponseBody @RequestMapping(&quot;/aa&quot;) public User setSchemaMapper()&#123; User user = schemaMapper.selectById(1); return user; &#125;&#125; 结果为 配置日志输出我们所有的sql是不可见的，我们希望知道他们是怎么执行的，所以要配置日志知道 12#配置日志 log-impl:日志实现mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl","path":"2021/10/26/MyBatis-Plus快速入门体验及配置日志输出/","date":"10-26","excerpt":"","tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://zangblog.gitee.io/tags/MyBatis-Plus/"}]},{"title":"常用基本命令","text":"目录管理 绝对路径和相对路径 我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 绝对路径： 路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。 相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法 处理目录的常用命令 接下来我们看几个常见的 处理目录的命令 ls：列出目录 cd：切换目录 pwd：显示当前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp：复制文件或目录 rm：移动文件或目录 mv：移动文件与目录，或修改文件与目录的名称 ls(列出目录) 在Linux系统当中， ls 命令可能是最常被运行的。 语法： [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称 选项与参数： -a：全部的文件连同隐藏文件(开头为.的文件)一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) cd (切换目录) cd是Change Directory的缩写，这是用来变换工作目录的命令。 语法： cd [相对或者绝对路径] 测试 1234567891011121314151617#切换的用户目录下[root@zangzang /]# cd home#使用 mkdir 命令创建 zangzang 目录[root@zangzang home]# mkdir zangzang#进入 zangzang 目录[root@zangzang home]# cd zangzang#回到上一级[root@zangzang zangzang]# cd ..#回到根目录[root@zangzang home]# cd /#表示回到自己的家目录，亦即是 /root 这个目录[root@zangzang /]# cd ~ pwd(显示目前所在的目录) pwd 是Print Working Directory 的缩写，也就是显示目前所在目录的命令. 选项与参数： -P ：显示出确实的路径，而非使用连结 (link) 路径。 测试: 12345678# 单纯显示出目前的工作目录[root@zangzang home]# pwd/home# 如果是链接要显示真实地址，可以使用 -p参数[root@zangzang /]# cd bin[root@zangzang bin]# pwd -P/usr/bin mkdir (创建新目录) 如果想要创建新的目录的话，那么就使用mkdir 语法： mkdir [-mp] 目录名录 选项与参数： -m: 配置文件的权限！ -p: 帮助你直接将所需要的目录(包含上一节目录)递归创建起来! 测试: 1234567891011121314151617181920212223# 进入我们的用户目录下[root@zangzang ~]# cd /home# 创建一个test文件夹[root@zangzang home]# mkdir test# 创建多层级目录[root@zangzang home]# mkdir test/test1/test2/test3mkdir: cannot create directory ‘test/test1/test2/test3’: No such file or directory # &lt;== 没办法直接创建此目录# 加了这个-p的选项，可以自行帮你创建多层目录！[root@zangzang home]# mkdir -p test/test1/test2/test3[root@zangzang home]# cd test/test1/test2/test3[root@zangzang test3]# pwd -P/home/test/test1/test2/test3# 创建权限为 rwx--x--x 的目录。[root@zangzang home]# mkdir -m 711 test1[root@zangzang home]# ls -lltotal 28drwx------ 3 admin admin 4096 Oct 21 19:03 admindrwx------ 3 springboot springboot 4096 Oct 21 20:14 springbootdrwxr-x--- 9 root root 4096 Aug 24 2017 staragentdrwxr-xr-x 3 root root 4096 Oct 24 09:29 testdrwx--x--x 2 root root 4096 Oct 24 09:34 test1drwxr-x--- 5 www www 4096 Oct 21 20:13 wwwdrwxr-xr-x 2 root root 4096 Oct 24 09:06 zangzang rmdir(删除空的目录) 语法： rmdir [-p] 目录名称 选项与参数：-p ：连同上一级『空的』目录也一起删除 测试： 1234567#可以直接删除掉，没问题[root@zangzang home]# rmdir test1# 因为尚有内容，所以无法删除！[root@zangzang home]# rmdir testrmdir: failed to remove ‘test’: Directory not empty# 利用 -p 这个选项，立刻就可以将test/test1/test2/test3 依次删除[root@zangzang home]# rmdir -p test/test1/test2/test3 注意：这个 rmdir 仅能删除空的目录，可以使用 rm 命令来删除非空目录，后面会说! cp(复制文件或目录) 语法： [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) [root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -r：递归持续复制，用於目录的复制行为；(常用) -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。 -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 测试： 12345678910# 找到一个有文件的目录，我们这里找root目录[root@zangzang home]# cd /root[root@zangzang ~]# lsenv.txt sa_recovery.log[root@zangzang ~]# cd /home# 复制root目录下的env.txt到 home 下[root@zangzang home]# cp /root/env.txt /home[root@zangzang home]# lsadmin env.txt springboot staragent www zangzang rm(移除文件或目录) 语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！ 12345678910# 将刚刚在 cp 的实例中创建的 install.sh删除掉！[root@zangzang ~]# cd /home[root@zangzang home]# lsadmin env.txt springboot staragent www zangzang[root@zangzang home]# rm -ri env.txtrm: remove regular file ‘env.txt’? y[root@zangzang home]# lsadmin springboot staragent www zangzang# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！# 尽量不要在服务器上使用 rm -rf / mv(移动文件与目录，或修改名称) 语法： [root@www ~]# mv [-fiu] source destination [root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 测试： 1234567891011121314151617# 复制一个文件到当前目录[root@kuangshen home]# cp /root/install.sh /home# 创建一个文件夹 test[root@kuangshen home]# mkdir test# 将复制过来的文件移动到我们创建的目录并查看[root@zangzang home]# mv env.txt test[root@zangzang home]# cd test[root@zangzang test]# lsenv.txt[root@zangzang test]# # 将文件重命名，然后在查看![root@zangzang test]# cd ..[root@zangzang home]# mv test mvtest[root@zangzang home]# lsadmin mvtest springboot staragent www zangzang[root@zangzang home]# 基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安 全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用 ll 或者 ls –l 命令来显示一个文件的属性以及文件所属的用户和组， 如： 实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有 者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限； 第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限； 第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权 限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 1、chgrp:更改文件属组 chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有 文件的属组都会更改。 2、chown:更改文件属主，也可以同时更改文件属组 chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 3、chmod:更改文件9个属性 chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute 权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组 的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： 1r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx– -] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 文件内容查看 概述 Linux系统中使用一下命令来查看文件的内容: cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 cat由第一行开始显示文件内容 语法： cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： 12345# 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/[root@zangzang /]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes tac tac与cat刚好相反,文件内容从最后一行开始显示，可以看出tac是cat 的倒着写！如： 1234[root@zangzang /]# tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0 nl 显示行号 语法： nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试 1234[root@zangzang /]# nl /etc/sysconfig/network-scripts/ifcfg-eth0 1 DEVICE=eth0 2 BOOTPROTO=dhcp 3 ONBOOT=yes more 一页一页翻动 在more这个程序的运行过程中，你有几个按键可以按： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 123[root@zangzang etc]# more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less 一页一页翻动，以下实例输出/etc/man.config文件的内容： less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； 123[root@zangzang etc]# more /etc/csh.login....(中间省略)....: # 这里可以等待你输入命令！ 扩展： Linux链接概念 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 情况下，ln 命令产生硬链接。 硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型 都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存 在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中 的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误 删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响 索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。 也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷 方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文 件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目 录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如 果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试 12345678910111213141516[root@zangzang /]# cd home[root@zangzang home]# touch f1 #创建一个测试文件f1[root@zangzang home]# lsadmin f1 mvtest springboot staragent www zangzang[root@zangzang home]# ln f1 f2 #创建f1的一个硬链接文件f2[root@zangzang home]# ln -s f1 f3 #创建f1的一个软链接文件f3[root@zangzang home]# ls -li #-i参数显示文件的inode节点信息total 24393286 drwx------ 3 admin admin 4096 Oct 21 19:03 admin395620 -rw-r--r-- 2 root root 0 Oct 24 16:01 f1395620 -rw-r--r-- 2 root root 0 Oct 24 16:01 f2396491 lrwxrwxrwx 1 root root 2 Oct 24 16:02 f3 -&gt; f1525271 drwxr-xr-x 2 root root 4096 Oct 24 11:40 mvtest525184 drwx------ 3 springboot springboot 4096 Oct 21 20:14 springboot393237 drwxr-x--- 9 root root 4096 Aug 24 2017 staragent 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 395620，然而符号连 接文件的 inode 节点不同。 12345678910111213[root@zangzang home]# echo &quot;I am f1 file&quot; &gt;&gt;f1[root@zangzang home]# cat f1I am f1 file[root@zangzang home]# cat f2I am f1 file[root@zangzang home]# cat f3I am f1 file[root@zangzang home]# rm -rf f1[root@zangzang home]# cat f2I am f1 file[root@zangzang home]# cat f3cat: f3: No such file or directory[root@zangzang home]# 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 Vim编辑器 什么是Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程 序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim键盘图 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和 底线命令模式（Last line mode）。 这三种模式的作用分别是： 命令模式 用户刚刚启动 vi/vim，便进入了命令模式. 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字 符，i被当作了一个命令。 以下是常用的几个命令： i切换到输入模式，以输入字符 x 删除当前光标所在处的字符 ：切换到底线命令模式，以在最低一行输入命令 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： 上手体验一下 如果你想要使用 vi 来建立一个名为 zangzang.txt 的文件时，你可以这样做： 1[root@zangzang home]# vim zangzang.txt 然后会进入文件 按下i进入输入模式,开始编辑文件 在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提 示。 这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进 行任何的编辑。 按下ESC按钮回到一般模式 好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按 下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！ 在一般模式中按下 :wq 储存后离开 vim！ OK! 这样我们就成功创建了一个 zangzang.txt 的文件。 Vim按键说明 除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 第二部分：一般模式切换到编辑模式的可用按钮说明 第三部分：一般模式切换到指令行模式的可用的按钮说明 账号管理 简介 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管 理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另 一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 用户账号的管理 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等 资源。 添加账号useradd 语法： useradd 选项 用户名 参数说明： 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -m 使用者目录如不存在则自动建立。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名: 指定新账号的登录名 测试： 12# 此命令创建了一个用户zangzanga，其中-m选项用来为登录名zangzang产生一个主目录/home/zangzanga[root@zangzang /]# useradd -m zangzanga 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 删除账号 如果一个用户的账号不再使用，可以从系统中删除。 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 删除一个已有的用户账号使用 userdel 命令，其格式如下： 语法： userdel 选项 用户名 常用的选项是 -r 他的作用是把用户的主目录一起删除. 1[root@zangzang ~]# userdel -r zangzanga 此命令删除用户zangzanga在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录， 同时删除用户的主目录。 修改账号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用 usermod 命令，其格式如下： usermod 选项 用户名 常用的选项包括 ==-c, -d, -m, -g, -G, -s, -u==以及-o等 ，这些选项的意义与 ==useradd== 命令中的选项 一样，可以为用户指定新的资源值。 例如： 1# usermod -s /bin/ksh -d /home/z –g developer sam 此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使 用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是 ==passwd== 。超级用户可以为自己和其他用户指定口令，普通用户只 能用它修改自己的口令。 命令的格式为： 1passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 如果默认用户名，则修改当前用户的口令。 例如，假设当前用户是sam，则下面的命令修改该用户自己的口令： 1234$ passwdOld password:******New password:*******Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： 123# passwd samNew password:*******Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两 次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小 写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： 1# passwd -d sam 此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： 1# passwd -l sam 用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户 组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的 更新。 新增一个新的用户组使用groupadd命令 groupadd 选项 用户 可以使用的选项有： -g GID 指定新用户组的组标识好(GID) -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同 实例1： 1[root@zangzang /]# groupadd zangone 此命令向系统增加了一个新组zangone，新的组标识号是在当前已有的最大组标识号的基础上＋1. 实例2： 1[root@zangzang ~]# groupadd -g 101 grouptwo 此命令向系统中增加了一个新组grouptwo，同时指定组的标识号是101. 如果要删除一个已有的用户组，使用groupdel命令 语法： groupdel 用户组 例如： 1[root@zangzang ~]# groupdel zangone 此命令从系统中删除zangone组 修改用户组的属性使用groupmod命令 语法： groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 12345# 此命令将用户组grouptwo的组标识符号修改为102[root@zangzang ~]# groupmod -g 102 grouptwo# 将组grouptwo的标识符号改为1000，组名修改为groupthree[root@zangzang ~]# groupmod -g 10000 -n groupthree grouptwo 切换组 如果一个用户属于多个组，那么用户可以在用户组之间切换，以便有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的的用户组。例如： 1$ newgrp root /etc/passwd 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。 下面分别介绍这些文件的内容。 /etc/passwd文件是用户管理工作涉及的最重要的一个文件。 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 这个文件对所有用户都是可读的。它的内容类似下面的例子： 123456789101112131415161718192021222324252627282930[root@zangzang ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinsystemd-bus-proxy:x:999:998:systemd Bus Proxy:/:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:998:997:User for polkitd:/:/sbin/nologintss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinchrony:x:997:995::/var/lib/chrony:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinnscd:x:28:28:NSCD Daemon:/:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinmysql:x:1001:1001::/home/mysql:/sbin/nologinwww:x:1002:1002::/home/www:/bin/bashadmin:x:1003:1003::/home/admin:/bin/bashspringboot:x:1004:1004::/home/springboot:/sbin/nologinzangzang:x:1005:1005::/home/zangzang:/bin/bash 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个 字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell “用户名”是代表用户账号的字符串。 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里 是分隔符。 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 “口令”一些系统中，存放着加密后的用户口令字。 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可 读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正 的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊 的字符，例如“x”或者“*”。 “用户标识号”是一个整数，系统内部用它来标识用户。 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们 视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账 号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 “组标识号”字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录。 “注释性描述”字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个 字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做 finger命令的输出。 “主目录”，也就是用户的起始工作目录。它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目 录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权 限，其他用户对此目录的访问权限则根据具体情况设置。 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命 令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有 sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默 认的登录Shell，即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退 出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 系统中有一类用户称为伪用户（pseudo users）。 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存 在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 常见的伪用户如下所示： 伪用户含义 bin 拥有可执行的用户命令文件 sys 拥有系统文件 adm 拥有账户文件 uucp UUCP使用 lp lp或lpd子系统使用 nobody NFS使用 /etc/shadow","path":"2021/10/24/常用基本命令/","date":"10-24","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://zangblog.gitee.io/tags/Linux/"}]},{"title":"Linux开机关机和基本目录介绍","text":"开机开机会启动很多程序，他们在windows叫做服务，在Linux叫做”守护进程” 开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中 会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示 的，输完回车即可！ 一般来说，用户的登录方式有三种： 命令行登录 ssh登录 图形界面登录 关机在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非 特殊情况下，不得已才会关机。 12345678910sync # 将数据由内存同步到硬盘中。shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。 系统目录结构登录系统后，在当前命令窗口下输入命令: 1ls / 你会看到 以下目录的解释 /bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些- 连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问 文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账 号命名的。 /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备 挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上， 然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个 目录下。默认是空的。 /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获 取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 /tmp：这个目录是用来存放一些临时文件的。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows 下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录 下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被 删掉或清除。","path":"2021/10/22/Linux开机关机和基本目录介绍/","date":"10-22","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://zangblog.gitee.io/tags/Linux/"}]},{"title":"如何将自己的springboot项目部署到阿里云服务器","text":"1、怎么购买服务器这里就不说了，直接去阿里云官网就行这里记住我们要设置安全组将自己要用的端口打开 2、下载一个xshell2.1 简单测试一下，你会发现网页登陆云服务器的方式有一个弊端，那就是只要一小段时间不操作，服务器就会进入休眠，又得输入连接密码才能激活，很烦。所以我们采用别的方式登录这个云服务器。 2.2 Xshell是一个终端模拟软件，换言之，我们只要在本地Windows系统下安装这个软件，打开输入账号密码，就能登录远程的云服务器 2.3 Xshell下载官网：https://xshell.en.softonic.com（如果官网下载太慢，可以百度一下Xshell，很多资源，下载最新版的就行，我用的是Xshell 7） 2.4 下载完了选择安装路径开始安装，这个软件很小，安装也简单，安装过程中不会出现问题（新手的我也一路畅通） 2.5 打开Xshell们可以看到如下界面： 2.6 新建一个会话，拿出之前的笔记，将公网IP输入到主机栏，端口号设置为22（服务器的监听端口，ftp默认为21，sftp为22，如果你设置22连不进去，那就换21试一下） 2.7 点击 ”确定”&gt;&gt;“连接”，继续拿出笔记，把服务器账号填进“登录的用户名”，把服务器密码填进“密码”，如下图。 2.8 登录成功，进入服务器。以后我们就可以通过这个界面对云服务器进行远程操控，在上面进行jdk，mysql安装，springboot部署等操作了。 3、在云服务器安装jdk3.1 先用Xshell 连接到你的云服务器（或者直接在阿里云官网中远程连接也行） 3.2 在你的本地Windows系统中下载 Linux系统下的jdk，jdk下载官网：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html。下载你需要的jdk版本，我用的是 jdk-8u221-linux-x64.tar.gz 。 3.3 然后我们要把这个文件传到云服务器上去。听起来很高端，其实很简单的。在Xshell上执行rz命令就可以实现。首先我们要在云服务器上安装这个命令。在Xshell中执行 1yum install lrzsz 3.4 我们要把上传的文件放到哪个目录，就要先cd进入那个目录。我们申请的服务器的初始目录结构如下：（cd命令：进入目录） 3.5 现在我们要把这个jdk安装包放到**/usr/java**目录下（如果没有该目录则需要创建目录。最好跟着我的安装路径来，不然后面的环境设置会比较麻烦），所以我们一步步cd到这个目录下： 然后 rz 把安装包上传上去（rz命令：上传文件） 1rz 3.6 执行rz命令会弹出一个文件选择框，选择安装包上传 3.7 等待上传完毕 3.8 接下来解压安装包就算安装成功了！使用tar命令解压压缩包，如果你下载的版本跟我不一样，记得把包名改成你自己的版本 。（tar命令：解压） 1tar -zxvf jdk-8u221-linux-x64.tar.gz 3.9 然后就跟你在windows系统下安装完jdk一样，你还要设置系统环境变量。linux系统中的设置方法为：找到文件 /etc/profile ，向其中添加如下代码： 1234export JAVA_HOME=/usr/java/jdk1.8.0_221export CLASSPATH=$JAVA_HOME/lib/export PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH 先cd进目录 /etc ，再使用 vim命令编辑文件profile（vim命令：编写修改文件内容） 到这个界面之后 按e键，之后按i进行编辑 之后按esc退出编辑然后输入:wq+回车保存，如果这里报错说我们没有权限的话可以使用:wq!+回车，强制保存 3.10 立即执行profile文件，使之生效，使用source命令（source命令：依次执行文件所有语句） 3.11 这里如果没有报错我们就进行验证一下 1java -version 如果显示版本号的话就说明我们成功了 4、打成jar包我们因为是springboot项目所以内置tomcat，我们只需要使用maven插件打包 记住我们此时项目所使用的端口号一定要在安全组里边打开 打成jar包之后我们继续使用rz命令将它上传到服务器中 使用java指令运行项目jar包，这样我们的项目就算部署成功了 1java -jar ***.jar //***为你的jar包名 这样我们使用ip地址：端口号就可以了 其实还有一种方法就是我们前边都一样，但是是打成war包，上传,然后使用宝塔进行傻瓜式部署这个不会的再问我我就不详细说了","path":"2021/10/21/将自己的springboot项目部署到阿里云服务器/","date":"10-21","excerpt":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zangblog.gitee.io/tags/SpringBoot/"}]},{"title":"SpringBoot集成logback日志","text":"1、首先搭建一个普通的具有查询功能的整体框架具体就不详细说了 1、创建pojo层1234567891011121314package com.example.logback.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123; private int id; private String username; private String password;&#125; 2、创建dao层2.1 创建dao层的mapper接口123456789package com.example.logback.dao;import com.example.logback.pojo.Employee;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface EmployeeMapper &#123; Employee getEmployeeById(Integer id);&#125; 2.2创建dao层的mapper接口所对应的xml文件123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个用来对应接口--&gt;&lt;mapper namespace=&quot;com.example.logback.dao.EmployeeMapper&quot;&gt; &lt;!--这个用来对接口里边的方法，以及所返回的类型--&gt; &lt;select id=&quot;getEmployeeById&quot; resultType=&quot;com.example.logback.pojo.Employee&quot; parameterType=&quot;int&quot;&gt; select * from employee where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3、创建service层3.1 接口12345678package com.example.logback.service;import com.example.logback.pojo.Employee;public interface EmployeeService &#123; Employee getEmployeeById(Integer id);&#125; 3.2impl实现类123456789101112131415161718package com.example.logback.service.impl;import com.example.logback.dao.EmployeeMapper;import com.example.logback.pojo.Employee;import com.example.logback.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; @Autowired private EmployeeMapper employeeMapper; @Override public Employee getEmployeeById(Integer id) &#123; return employeeMapper.getEmployeeById(id); &#125;&#125; 编写properties配置文件1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/clothes_oa?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=zangzang 4、创建控制层进行测试12345678910111213141516171819package com.example.logback.controller;import com.example.logback.service.impl.EmployeeServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class Test &#123; @Autowired private EmployeeServiceImpl employeeService; @RequestMapping(value = &quot;/test&quot;) @ResponseBody public Object getEmployee(Integer id)&#123; return employeeService.getEmployeeById(1); &#125;&#125; 得到一个json 2、引入logback依赖因为我们springboot的启动依赖内置的所以不用引入 3、","path":"2021/10/19/SpringBoot集成logback日志/","date":"10-19","excerpt":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zangblog.gitee.io/tags/SpringBoot/"}]},{"title":"Nginx","text":"什么是NginxNginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。 其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。 Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。 Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。 Nginx作用 Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理 正向代理 正如我们访问GitHub的时候，由于他的服务器在外网而我们是在中国中间隔着一道墙，此时我们去挂一个VPN，就可以正常访问了。 客户端就相当于我们的电脑，然后使用vpn就相当于使用的代理，假如vpn在香港，由于他可以访问外网，此时我们去请求香港的服务器然后他代理我们去请求外网的服务器，返回数据到香港然后香港的服务器再返回给我们。 代理我们客户端的就为正向代理，所以反向代理就为代理服务器的 反向代理 例如百度我们每次访问百度都是访问 《www.baidu.com》 这个域名而他并不是只存放在一台服务器上只是都由一个代理将这些服务器代理了 我们后面的服务器无论动态扩容多少台服务器客户端都没有感知，他只需要访问这一个地址就可以了，这就是反向代理 负载均衡的理解 Nginx提供的负载均衡策略有两种：内置策略和扩展策略，内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不想到没有他做不到 轮询 轮询就是假如我们有三台服务器第一个请求访问第一台服务器，第二次请求访问第二台，第三次请求访问第三台接下来第四次又访问回第一台 加权轮询 假如有一台服务器性能比较好我们就可以给他高一些的权重让他负责更多一些的请求， iphash iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。但是如果服务器挂掉所有的信息就会丢失。所以一般还是用Redis，因为如果服务器挂掉之后session会钝化，等重启之后活化。关于钝化和活化可以访问Session 的钝化与活化。 动静分离动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。 我们先了解到这，在windows和Linux环境下的安装和基本使用以后会说","path":"2021/10/18/Nginx/","date":"10-18","excerpt":"","tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://zangblog.gitee.io/tags/Nginx/"}]},{"title":"SpringBoot支持事务","text":"SpringBoot支持事务事务是一个完整的功能也叫做一个完整的业务 事务只跟DML语句有关系下面我们通过实例来测试一下 1、新建一个项目,然后导入maven依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;dependencies&gt; &lt;!-- 引入模板引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 2、我们这个项目以之前我已经做好的一个人力资源管理系统中的一个员工表来进行测试3、在配置文件中编写连接数据库数据123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/clothes_oa?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=zangzangserver.port=9522 这里注意这个spring.datasource.driver-class-name，如果使用的8.0以上版本就要加jc 4、创建实体类12345678910111213141516package com.example.affairstest.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123; private int id; private String username; private String password; &#125; 5、创建dao层5.1、创建EmployeeMapper接口12345678package com.example.affairstest.dao;import com.example.affairstest.pojo.Employee;public interface EmployeeMapper &#123; //增加一名员工 int insertEmployee(Employee employee);&#125; 5.2、创建对应的EmployeeMapper.xml文件123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个用来对应接口--&gt;&lt;mapper namespace=&quot;com.zang.dao.EmployeeMapper&quot;&gt; &lt;!--这个用来对接口里边的方法，以及所返回的类型--&gt; &lt;insert id=&quot;getUserList&quot; parameterType=&quot;com.zang.pojo.Employee&quot; &gt; insert into employee (id,username,password) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 6、创建service层12345678910package com.example.affairstest.service;import com.example.affairstest.pojo.Employee;public interface EmployeeService &#123; //增加一名员工 int insertEmployee(Employee employee); //根据id查询员工 Employee getEmployeeById(int id);&#125; 1234567891011121314151617181920212223package com.example.affairstest.service.impl;import com.example.affairstest.dao.EmployeeMapper;import com.example.affairstest.pojo.Employee;import com.example.affairstest.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; @Autowired private EmployeeMapper mapper; @Override public int insertEmployee(Employee employee) &#123; int i = mapper.insertEmployee(employee); return i; &#125; @Override public Employee getEmployeeById(int id) &#123; return mapper.getEmployeeById(id); &#125;&#125; 7、创建controller进行测试 1234567891011121314151617181920package com.example.affairstest.controller;import com.example.affairstest.service.impl.EmployeeServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.Mapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class Test &#123; @Autowired private EmployeeServiceImpl service; @ResponseBody @RequestMapping(&quot;/a&quot;) public String One()&#123; return &quot; &quot;+service.getEmployeeById(1); &#125;&#125; 可以正常运行 8、我们写一个增加员工的接口然后service层在调用业务后面写一个int a=10/0；的异常模仿事务出错，然后去进行使用，会发现虽然程序报错但是仍然会插入成功，这就很恐怖了，因为我们这是一个完整的事务所以要么全成功要么全失败。此时我们需要在业务方法上边添加一个注解@Transactional这样就给业务添加了注解。","path":"2021/10/13/SpringBoot支持事务/","date":"10-13","excerpt":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zangblog.gitee.io/tags/SpringBoot/"}]},{"title":"整合SSM","text":"整合SSM 环境要求 环境： IDEA MySQL 5.7 Tomcat9 Maven 3.6 要求： 熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis只是，简单的前端知识； 数据库环境 创建一个存放书籍的数据库表 123456789101112131415161718CREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` (`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;书id&#x27;,`bookName` VARCHAR(100) NOT NULL COMMENT &#x27;书名&#x27;,`bookCounts` INT(11) NOT NULL COMMENT &#x27;数量&#x27;,`detail` VARCHAR(200) NOT NULL COMMENT &#x27;描述&#x27;,KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,&#x27;Java&#x27;,1,&#x27;从入门到放弃&#x27;),(2,&#x27;MySQL&#x27;,10,&#x27;从删库到跑路&#x27;),(3,&#x27;Linux&#x27;,5,&#x27;从进门到进牢&#x27;); 基本环境搭建 1、新建Maven项目ssmbuild,添加web支持 2、导入相关的pom依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、Maven资源过滤设置 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 4、建立基本结构和配置框架 com.zang.pojo com.zang.dao com.zang.service com.zang.controller mybatis-config.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; MyBatis层编写 1、数据库配置文件database.properties 1234url=jdbc:mysql://localhost:3306/ssmbuild?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falseusername=rootpassword=zangzangdriver-class-name=com.mysql.cj.jdbc.Driver 2、编写mybatis核心配置文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--起别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.zang.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!--绑定mapper文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;BookMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3、编写数据库对应的实体类com.zang.pojo.BookS 使用lombok插件 1234567891011121314151617package com.zang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail;&#125; 4、编写Dao层的Mapper接口 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个用来对应接口--&gt;&lt;mapper namespace=&quot;com.zang.dao.BookMapper&quot;&gt; &lt;!--根据id删除指定用户--&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt; delete from books where id=&#123;#bookId&#125; &lt;/delete&gt; &lt;!--增加一本书--&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;com.zang.pojo.Books&quot;&gt; insert into books (bookName,bookCounts,detail) values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;) &lt;/insert&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;int&quot;&gt; update books set bookName=#&#123;bookName&#125;,bookCounts=#&#123;bookCounts&#125;,detail=#&#123;detail&#125; where bookID=#&#123;bookID&#125; &lt;/update&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;com.zang.pojo.Books&quot;&gt; select * from books &lt;/select&gt; &lt;select id=&quot;queryBookById&quot; resultType=&quot;int&quot;&gt; select * from books where bookID=#&#123;bookID&#125; &lt;/select&gt;&lt;/mapper&gt; 6、编写Service层的接口和实现类 接口 1234567891011121314151617181920212223package com.zang.service;import com.zang.pojo.Books;import java.util.List;public interface BookService &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(int id); //更新一本书 int updateBook(Books books,int id); //查询一本书 Books queryBookById(int id); //查询全部的书 List&lt;Books&gt; queryAllBook();&#125; 实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zang.service;import com.zang.dao.BookMapper;import com.zang.pojo.Books;import java.util.List;public class BookServiceImpl implements BookService &#123; //service调dao层： 组合Dao private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) &#123; this.bookMapper = bookMapper; &#125; public int addBook(Books books) &#123; String m=&quot;adawsd&quot;; String n=&quot;adawsd&quot;; if(m==n)&#123; &#125; return bookMapper.addBook(books); &#125; public int deleteBookById(int id) &#123; return bookMapper.deleteBookById(id); &#125; public int updateBook(Books books,int id) &#123; return bookMapper.updateBook(books,id); &#125; public Books queryBookById(int id) &#123; return bookMapper.queryBookById(id); &#125; public List&lt;Books&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125;&#125; 此时底层需求操作编写完毕！ Spring层1、配置Spring整合MyBatis,我们这里使用c3p0连接池 2、我们编写Spring整合MyBatis的相关的配置文件：spring-dao.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--关联数据库对应文件--&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!--数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--配置连接池属性--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactory对象--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--配置扫描Dao接口包，动态实现Dao接口包注入到IOC容器中--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--注入sqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--给出需要扫描的Dao接口包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.zang.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3、Spring整合Service层 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--扫描service相关包--&gt; &lt;context:component-scan base-package=&quot;com.zang.service&quot;/&gt; &lt;!--BookServiceImpl注入到ioc--&gt; &lt;bean class=&quot;com.zang.service.BookServiceImpl&quot; id=&quot;service&quot;&gt; &lt;property name=&quot;bookMapper&quot; value=&quot;bookMapper&quot;/&gt; &lt;/bean&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; SpringMVC层1、web.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 2、spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.zang.controller&quot; /&gt;&lt;/beans&gt; 整合完毕","path":"2021/10/06/整合SSM/","date":"10-06","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zangblog.gitee.io/tags/SpringMVC/"}]},{"title":"SpringMVC笔记","text":"[TOC] 一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器 2、什么是SpringMVCSpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet 3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld1、开发环境IDE：idea 2019.2 构建工具：maven3.5.4 服务器：tomcat7 Spring版本：5.3.1 2、创建maven工程a&gt;添加web模块b&gt;打包方式：warc&gt;引入依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 3、配置web.xml注册SpringMVC的前端控制器DispatcherServlet a&gt;默认配置方式此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml 1234567891011121314&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; b&gt;扩展配置方式可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间 123456789101112131415161718192021222324252627&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注： &lt;url-pattern&gt;标签中使用/和/*的区别： /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法 4、创建请求控制器由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器 请求控制器中每一个处理请求的方法成为控制器方法 因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在 1234@Controllerpublic class HelloController &#123; &#125; 5、创建springMVC的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 自动扫描包 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&gt;&lt;!-- 配置Thymeleaf视图解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 开启mvc注解驱动 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!-- 处理响应中文内容乱码 --&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 6、测试HelloWorlda&gt;实现对首页的访问在请求控制器中创建处理请求的方法 12345678// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径// localhost:8080/springMVC/@RequestMapping(&quot;/&quot;)public String index() &#123; //设置视图名称 return &quot;index&quot;;&#125; b&gt;通过超链接跳转到指定页面在主页index.html中设置超链接 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 在请求控制器中创建处理请求的方法 1234@RequestMapping(&quot;/hello&quot;)public String HelloWorld() &#123; return &quot;target&quot;;&#125; 7、总结浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面 三、@RequestMapping注解1、@RequestMapping注解的功能从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 2、@RequestMapping注解的位置@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息 1234567891011@Controller@RequestMapping(&quot;/test&quot;)public class RequestMappingController &#123; //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping()&#123; return &quot;success&quot;; &#125;&#125; 3、@RequestMapping注解的value属性@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射 12&lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; 123456@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 4、@RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported 1234&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;&lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 1234567@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射–&gt;@GetMapping 处理post请求的映射–&gt;@PostMapping 处理put请求的映射–&gt;@PutMapping 处理delete请求的映射–&gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到 5、@RequestMapping注解的params属性（了解）@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 “param”：要求请求映射所匹配的请求必须携带param请求参数 “!param”：要求请求映射所匹配的请求必须不能携带param请求参数 “param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value “param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value 1&lt;a th:href=&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt; 12345678@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456} 6、@RequestMapping注解的headers属性（了解）@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 @RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系 “header”：要求请求映射所匹配的请求必须携带header请求头信息 “!header”：要求请求映射所匹配的请求必须不能携带header请求头信息 “header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value “header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到 7、SpringMVC支持ant风格的路径？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意的一层或多层目录 注意：在使用**时，只能使用/**/xxx的方式 8、SpringMVC支持路径中的占位符（重点）原始方式：/deleteUser?id=1 rest方式：/deleteUser/1 SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参 1&lt;a th:href=&quot;@&#123;/testRest/1/admin&#125;&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt; 123456@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username)&#123; System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;;&#125;//最终输出的内容为--&gt;id:1,username:admin 四、SpringMVC获取请求参数1、通过ServletAPI获取将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象 1234567@RequestMapping(&quot;/testParam&quot;)public String testParam(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 2、通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参 1&lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 3、@RequestParam@RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值 4、@RequestHeader@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 5、@CookieValue@CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 6、通过POJO获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值 12345678&lt;form th:action=&quot;@&#123;/testpojo&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 123456@RequestMapping(&quot;/testpojo&quot;)public String testPOJO(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125;//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125; 7、解决获取请求参数的乱码问题解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册 1234567891011121314151617&lt;!--配置springMVC的编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效 五、域对象共享数据1、使用ServletAPI向request域对象共享数据12345@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;&#125; 2、使用ModelAndView向request域对象共享数据1234567891011121314@RequestMapping(&quot;/testModelAndView&quot;)public ModelAndView testModelAndView()&#123; /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav;&#125; 3、使用Model向request域对象共享数据12345@RequestMapping(&quot;/testModel&quot;)public String testModel(Model model)&#123; model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;&#125; 4、使用map向request域对象共享数据12345@RequestMapping(&quot;/testMap&quot;)public String testMap(Map&lt;String, Object&gt; map)&#123; map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;;&#125; 5、使用ModelMap向request域对象共享数据12345@RequestMapping(&quot;/testModelMap&quot;)public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;;&#125; 6、Model、ModelMap、Map的关系Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的 1234public interface Model&#123;&#125;public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125; 7、向session域共享数据12345@RequestMapping(&quot;/testSession&quot;)public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;&#125; 8、向application域共享数据123456@RequestMapping(&quot;/testApplication&quot;)public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;;&#125; 六、SpringMVC的视图SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView 1、ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 1234@RequestMapping(&quot;/testHello&quot;)public String testHello()&#123; return &quot;hello&quot;;&#125; 2、转发视图SpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转 例如”forward:/“，”forward:/employee” 1234@RequestMapping(&quot;/testForward&quot;)public String testForward()&#123; return &quot;forward:/testHello&quot;;&#125; 3、重定向视图SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转 例如”redirect:/“，”redirect:/employee” 1234@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect()&#123; return &quot;redirect:/testHello&quot;;&#125; 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径 4、视图控制器view-controller当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示 12345&lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&gt;&lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签： &lt;mvc:annotation-driven /&gt; 七、RESTful1、RESTful简介REST：Representational State Transfer，表现层资源状态转移。 a&gt;资源资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 b&gt;资源的表述资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 c&gt;状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 2、RESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id=1 user/1–&gt;get请求方式 保存操作 saveUser user–&gt;post请求方式 删除操作 deleteUser?id=1 user/1–&gt;delete请求方式 更新操作 updateUser user–&gt;put请求方式 3、HiddenHttpMethodFilter由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter 处理put和delete请求的条件： a&gt;当前请求的请求方式必须为post b&gt;当前请求必须传输请求参数_method 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式 在web.xml中注册HiddenHttpMethodFilter 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因： 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的 request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作： ```String paramValue = request.getParameter(this.methodParam); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 八、RESTful案例### 1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。- 搭建环境- 准备实体类 ```java package com.atguigu.mvc.bean; public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125; &#125; 准备dao模拟数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.mvc.dao;import java.util.Collection;import java.util.HashMap;import java.util.Map;import com.atguigu.mvc.bean.Employee;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 2、功能清单 功能 URL 地址 请求方式 访问首页√ / GET 查询全部数据√ /employee GET 删除√ /employee/2 DELETE 跳转到添加数据页面√ /toAdd GET 执行保存√ /employee POST 跳转到更新数据页面√ /employee/2 GET 执行更新√ /employee PUT 3、具体功能：访问首页a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; b&gt;创建页面1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;访问员工信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4、具体功能：查询所有员工数据a&gt;控制器方法123456@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)public String getEmployeeList(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;, employeeList); return &quot;employee_list&quot;;&#125; b&gt;创建employee_list.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;text-align: center;&quot; id=&quot;dataTable&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5、具体功能：删除a&gt;创建处理delete请求方式的表单12345&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;&lt;form id=&quot;delete_form&quot; method=&quot;post&quot;&gt; &lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt;&lt;/form&gt; b&gt;删除超链接绑定点击事件引入vue.js 1&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; 删除超链接 1&lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; 通过vue处理点击事件 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; //event表示当前事件 deleteEmployee:function (event) &#123; //通过id获取表单标签 var delete_form = document.getElementById(&quot;delete_form&quot;); //将触发事件的超链接的href属性为表单的action属性赋值 delete_form.action = event.target.href; //提交表单 delete_form.submit(); //阻止超链接的默认跳转行为 event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法12345@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;;&#125; 6、具体功能：跳转到添加数据页面a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; b&gt;创建employee_add.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Add Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7、具体功能：执行保存a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 8、具体功能：跳转到更新数据页面a&gt;修改超链接1&lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; b&gt;控制器方法123456@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;, employee); return &quot;employee_update&quot;;&#125; c&gt;创建employee_update.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Update Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt; &lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性 --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 9、具体功能：执行更新a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 八、HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity， ResponseEntity 1、@RequestBody@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值 12345&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123; System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;;&#125; 输出结果： requestBody:username=admin&amp;password=123456 2、RequestEntityRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 123456@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;;&#125; 输出结果：requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”http://localhost:8080&quot;, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]requestBody:username=admin&amp;password=123 3、@ResponseBody@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器 12345@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody()&#123; return &quot;success&quot;;&#125; 结果：浏览器页面显示success 4、SpringMVC处理json@ResponseBody处理json的步骤： a&gt;导入jackson的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串 1&lt;mvc:annotation-driven /&gt; c&gt;在处理器方法上使用@ResponseBody注解进行标识 d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 12345@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);&#125; 浏览器的页面中展示的结果： {“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”} 5、SpringMVC处理ajaxa&gt;请求超链接： 123&lt;div id=&quot;app&quot;&gt; &lt;a th:href=&quot;@&#123;/testAjax&#125;&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt;&lt;/div&gt; b&gt;通过vue和axios处理点击事件： 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; testAjax:function (event) &#123; axios(&#123; method:&quot;post&quot;, url:event.target.href, params:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125; &#125;).then(function (response) &#123; alert(response.data); &#125;); event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法： 123456@RequestMapping(&quot;/testAjax&quot;)@ResponseBodypublic String testAjax(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;;&#125; 6、@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解 7、ResponseEntityResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 九、文件上传和下载1、文件下载使用ResponseEntity实现下载文件的功能 123456789101112131415161718192021222324@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity;&#125; 2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data” SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 上传步骤： a&gt;添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的配置文件中添加配置： 12&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; c&gt;控制器方法： 12345678910111213141516171819@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123; //获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists())&#123; file.mkdir(); &#125; String finalPath = photoPath + File.separator + fileName; //实现上传功能 photo.transferTo(new File(finalPath)); return &quot;success&quot;;&#125; 十、拦截器1、拦截器的配置SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： 1234567891011&lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;/mvc:interceptor&gt;&lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&gt; 2、拦截器的三个抽象方法SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation() 3、多个拦截器的执行顺序a&gt;若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行 b&gt;若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行 十一、异常处理器1、基于配置的异常处理SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式： 123456789101112131415&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、基于注解的异常处理12345678910111213//@ControllerAdvice将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController &#123; //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model)&#123; model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; &#125;&#125; 十二、注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能 1、创建初始化类，代替web.xml在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。 123456789101112131415161718192021222324252627282930313233343536373839404142public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;; &#125;&#125; 2、创建SpringConfig配置类，代替spring的配置文件1234@Configurationpublic class SpringConfig &#123; //ssm整合之后，spring的配置信息写在此类中&#125; 3、创建WebConfig配置类，代替SpringMVC的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configuration//扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)//开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; //使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver(); &#125; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); &#125; //配置视图控制 /*@Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125;*/ //配置异常映射 /*@Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); &#125;*/ //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;&#125; 4、测试功能1234@RequestMapping(&quot;/&quot;)public String index()&#123; return &quot;index&quot;;&#125; 十三、SpringMVC执行流程1、SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户 2、DispatcherServlet初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。 a&gt;初始化WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected WebApplicationContext initWebApplicationContext() &#123; WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 创建WebApplicationContext wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) &#123; // 刷新WebApplicationContext onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. // 将IOC容器在应用域共享 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; b&gt;创建WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 1234567891011121314151617181920212223protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac;&#125; c&gt;DispatcherServlet初始化策略FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet 1234567891011protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; 3、DispatcherServlet调用组件处理请求a&gt;processRequest()FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125;&#125; b&gt;doService()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123; requestPath = ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; // 处理请求和响应 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (requestPath != null) &#123; ServletRequestPathUtils.clearParsedRequestPath(request); &#125; &#125;&#125; c&gt;doDispatch()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; d&gt;processDispatchResult()12345678910111213141516171819202122232425262728293031323334353637383940414243private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; 4、SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： a) 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误 iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误 b) 存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。","path":"2021/09/28/SpringMVC笔记-转自尚硅谷/","date":"09-28","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zangblog.gitee.io/tags/SpringMVC/"}]},{"title":"Spring声明式事务","text":"事务回顾 把一组业务当成一个业务来做，要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID 原子性 要么都成功要么都失败 一致性 数据前后总值不变 隔离性 多个业务可能操作同一个资源，防止数据损坏 持久性 事务一旦提交，无论系统发生什么问题，结果都不会在被影响，被持久化的写到存储器 事务管理首先我们编写一个正常的用于插入和删除的实例 pojo12345678@Data@NoArgsConstructor@AllArgsConstructorpublic class Employee &#123; private int id; private String name; private String pwd;&#125; dao1234public interface EmployeeMapper &#123; int insertEmployee(Employee employee); int deleteEmployee(int id);&#125; 对应mapper文件 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个用来对应接口--&gt;&lt;mapper namespace=&quot;com.zang.dao.EmployeeMapper&quot;&gt; &lt;!--这个用来对接口里边的方法，以及所返回的类型--&gt; &lt;insert id=&quot;insertEmployee&quot; parameterType=&quot;com.zang.pojo.Employee&quot;&gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteEmployee&quot; parameterType=&quot;_int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; service1234public interface EmployeeService &#123; int insertEmployee(Employee employee); int deleteEmployee(int id);&#125; 实现类 12345678910111213141516171819202122public class EmployeeServiceImpl implements EmployeeService &#123; private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public int insertEmployee(Employee employee) &#123; EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); int i = mapper.insertEmployee(employee); return i; &#125; @Override public int deleteEmployee(int id) &#123; EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); mapper.deleteEmployee(id);return id; &#125;&#125; 配置文件123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;DataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=GMT&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;zangzang&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;DataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/zang/dao/*.xml&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;employee&quot; class=&quot;com.zang.service.impl.EmployeeServiceImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt; &lt;/bean&gt; &lt;bean id =&quot;employeeOne&quot; class=&quot;com.zang.pojo.Employee&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;12&quot;/&gt; &lt;property name=&quot;pwd&quot; value=&quot;zangzang&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;小臧&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.zang.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; test123456789101112131415161718192021222324public class OneTest &#123; @Test public void TestOne()&#123; String name = &quot;applicationContext.xml&quot;; ApplicationContext context = new ClassPathXmlApplicationContext(name); Employee bean = context.getBean(&quot;employeeOne&quot;, Employee.class); EmployeeService sqlSession = context.getBean(&quot;employee&quot;, EmployeeService.class); int i = sqlSession.insertEmployee(bean); if(i&gt;0)&#123; System.out.println(&quot;插入成功&quot;); &#125; &#125; @Test public void deleteOne()&#123; String name=&quot;applicationContext.xml&quot;; ApplicationContext context = new ClassPathXmlApplicationContext(name); EmployeeService employee = context.getBean(&quot;employee&quot;, EmployeeService.class); int i = employee.deleteEmployee(12); if(i&gt;0)&#123; System.out.println(&quot;删除成功&quot;); &#125; &#125;&#125; 我们此时测试是正常的但是如果我们将插入的sql语句更改一下 1insert* into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) 此时虽然会报错但是仍然会插入成功 我们为了防止这种事情发生要使用事务 使用aop的思想将事务切入 1234567891011121314151617&lt;!--配置声明式事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg ref=&quot;DataSource&quot;/&gt; &lt;/bean&gt; &lt;!--将事务切入--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;insertEmployee&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;deleteEmployee&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txput&quot; expression=&quot;execution(* com.zang.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txput&quot;/&gt; &lt;/aop:config&gt; 此时就不会发生刚刚那种情况","path":"2021/09/26/Spring声明式事务/","date":"09-26","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"整合Mybatis","text":"Spring集成mybatis1、创建实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.zang.pojo;public class Employee &#123; private int id; private String name; private String password; private String address; //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;delombok&quot;&gt; @SuppressWarnings(&quot;all&quot;) public int getId() &#123; return this.id; &#125; @SuppressWarnings(&quot;all&quot;) public String getName() &#123; return this.name; &#125; @SuppressWarnings(&quot;all&quot;) public String getPassword() &#123; return this.password; &#125; @SuppressWarnings(&quot;all&quot;) public String getAddress() &#123; return this.address; &#125; @SuppressWarnings(&quot;all&quot;) public void setId(final int id) &#123; this.id = id; &#125; @SuppressWarnings(&quot;all&quot;) public void setName(final String name) &#123; this.name = name; &#125; @SuppressWarnings(&quot;all&quot;) public void setPassword(final String password) &#123; this.password = password; &#125; @SuppressWarnings(&quot;all&quot;) public void setAddress(final String address) &#123; this.address = address; &#125; @Override @SuppressWarnings(&quot;all&quot;) public boolean equals(final Object o) &#123; if (o == this) return true; if (!(o instanceof Employee)) return false; final Employee other = (Employee) o; if (!other.canEqual((Object) this)) return false; if (this.getId() != other.getId()) return false; final Object this$name = this.getName(); final Object other$name = other.getName(); if (this$name == null ? other$name != null : !this$name.equals(other$name)) return false; final Object this$password = this.getPassword(); final Object other$password = other.getPassword(); if (this$password == null ? other$password != null : !this$password.equals(other$password)) return false; final Object this$address = this.getAddress(); final Object other$address = other.getAddress(); if (this$address == null ? other$address != null : !this$address.equals(other$address)) return false; return true; &#125; @SuppressWarnings(&quot;all&quot;) protected boolean canEqual(final Object other) &#123; return other instanceof Employee; &#125; @Override @SuppressWarnings(&quot;all&quot;) public int hashCode() &#123; final int PRIME = 59; int result = 1; result = result * PRIME + this.getId(); final Object $name = this.getName(); result = result * PRIME + ($name == null ? 43 : $name.hashCode()); final Object $password = this.getPassword(); result = result * PRIME + ($password == null ? 43 : $password.hashCode()); final Object $address = this.getAddress(); result = result * PRIME + ($address == null ? 43 : $address.hashCode()); return result; &#125; @Override @SuppressWarnings(&quot;all&quot;) public String toString() &#123; return &quot;Employee(id=&quot; + this.getId() + &quot;, name=&quot; + this.getName() + &quot;, password=&quot; + this.getPassword() + &quot;, address=&quot; + this.getAddress() + &quot;)&quot;; &#125; @SuppressWarnings(&quot;all&quot;) public Employee(final int id, final String name, final String password, final String address) &#123; this.id = id; this.name = name; this.password = password; this.address = address; &#125; @SuppressWarnings(&quot;all&quot;) public Employee() &#123; &#125; //&lt;/editor-fold&gt;&#125; 2、创建dao层接口以及mapper文件1234public interface EmployeeDao &#123; Employee selectNameById(int id); List&lt;EmployeeDao&gt; selectEmployee(Map map);&#125; 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个用来对应接口--&gt;&lt;mapper namespace=&quot;com.zang.dao.EmployeeDao&quot;&gt; &lt;select id=&quot;selectNameById&quot; resultType=&quot;com.zang.pojo.Employee&quot; parameterType=&quot;int&quot;&gt; select * from employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3、创建service层接口以及实现类1234public interface EmployeeService &#123; Employee selectNameById(int id);&#125; 12345678910111213141516public class EmployeeServiceImpl implements EmployeeService &#123; private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public Employee selectNameById(int id) &#123; EmployeeDao mapper = sqlSession.getMapper(EmployeeDao.class); Employee employee = mapper.selectNameById(1); return employee; &#125;&#125; 4、mybatis配置文件12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.zang.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 5、spring核心配置文件12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;bean id=&quot;DataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/clothes_oa?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=GMT&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;zangzang&quot;/&gt;&lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;DataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatisconfig.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/zang/dao/*.xml&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;employee&quot; class=&quot;com.zang.service.impl.EmployeeServiceImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 6、测试123456789public class OneTest &#123; @Test public void testOne()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); EmployeeService employee =(EmployeeService)context.getBean(&quot;employee&quot;); Employee employee1 = employee.selectNameById(1); System.out.println(employee1); &#125;&#125;","path":"2021/09/24/整合Mybatis/","date":"09-24","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"aspectJ基于注解的AOP实现(重点)","text":"1、@AfterReturning后置通知1、在接口增加一个doOther方法 2、在真实对象中去实现 3、在切面中去增加后置通知 特点： 在目标方法之后执行的 2. 能够获取到目标方法中的返回值，可以根据这个返回值做不同除了功能 3. 可以修改这个返回值 2、环绕通知@Around(功能最强)1、在接口中增加一个方法doFirst 2、真实对象去实现doFirst方法 3、在切面中去增加环绕通知12345678910111213141516171819202122232425262728293031323334/** * 环绕通知方法的定义格式 * 1. public * 2.必须有一个返回值，推荐使用Object * 3.方法名称自定义 * 4. 方法有参数 固定的参数ProceedingJoinPoint *//** * @Around ：环绕通知 * 属性：value：切入点表达式 * 特点： * 1. 他是功能最强的通知 * 2. 在目标方法的前和后增加功能 * 3. 可以控制目标方法是否调用 * 4. 修改原来目标方法的执行结果。影响最后的调用结果 * * 环绕通知：等同于jdk动态代理的InvocationHandler * ProceedingJoinPoint 等同于动态Method： * 作用执行目标方法 * 返回值：就是目标方法的执行结果，可以被修改 */@Around(&quot;execution(* *..LoginServiceImpl.doFirst(..))&quot;)public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; //实现环绕方法 Object proceed=null; System.out.println(&quot;环绕通知：在目标方法之前&quot;+ new Date()); //1. 目标方法的调用 proceed = pjp.proceed(); //等同于method.invoke() System.out.println(&quot;环绕通知：在目标方法之后，提交事务&quot;); //2.增加功能 //3. 返回目标函数的执行结果 return proceed ;&#125; 4、测试 环绕功能的强大不仅如此 假如我们现在想判断一下传进来的参数是不是我们想要的如果不是我们就不去执行真实对象的方法 我们可以去使用pjp.getArgs()方法去获取实参然后进行判断，因为我们点进ProceedingJoinPoint之后会发现他继承了PoinPoint所以可以直接使用 这样就可以对其传进来的参数进行判断 修改目标方法的执行结果 3、异常通知@AfterThrowing其实没啥必要，就是通知了个寂寞，这里我就不写了 4、最终通知@After和前边使用方法一致，一般用于资源清理 5、前置通知@Before我之前例子已经使用了这就就不说了","path":"2021/09/19/aspectJ基于注解的AOP实现-重点/","date":"09-19","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"JoinPoint","text":"","path":"2021/09/19/JoinPoint/","date":"09-19","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"AOP","text":"1、AOP概述AOP(面向切面编程。面向切面编程是从动态角度考虑程序运行过程) 面向切面编程，可通过运行期动态代理实现程序功能的统一维护的一种技术。AOP是Spring框架中的一个重要内容，利用AOP课余对业务的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高了开发的效率 AOP的底层采用了动态代理实现的，采用了JDK的动态代理，与CGLIB的动态代理 面向切面编程，就是将较差业务逻辑封装成切面，利用AOP容器的功能将切面织入到主业务逻辑中，所谓的交叉业务逻辑是指通用的、与主业务逻辑无关的代码如安全检查、事务、日志、缓存等 动态代理​ 实现方式：jdk动态代理，使用jdk中的Proxy，Method，InvocationHander创建代理对象 ​ jdk代理要求，目标类必须实现接口 细节去看我之前发的代理模式 ​ cglib动态代理：第三方的工具类，创建代理对象，原理是继承通过继承目标类创建子类。子类就是代理对象，要求目标类不能是final的方法也不能是final的 ​ 动态代理的作用: 1. 在目标类源代码不改变的情况下，增加功能 2. 减少代码的重复 3. 专注业务逻辑 4. 解耦，让业务功能和非业务功能分离 面向切面的理解 Aspect：切面，给你的目标类增加功能，就是切面，切面的特点，一般都是非业务方法，独立使用 Orient：面向，对着 Programming：编程 怎么理解： 需要分析项目功能时，找出切面 合理的安排切面执行时间，（在目标方法前，还是目标方法后） 合理的安全切面执行的位置，在哪个类，哪个方法增加增强功能 术语Aspect：切面，表示增强的功能，就是一堆代码完成某一个功能。非业务常见的切面功能有日志，事务，统计信息，参数检查，权限验证。 JoinPoint：连接点，连接业务方法和切面的位置，就是某个类中的业务方法 Pointcut：切入点，指多个连接点方法的结合。实际真实被增强的方法 目标对象：给哪个类的方法实现增强功能，这个类就是目标对象 Advice：通知，表示切面功能实现的时间 怎么理解面向切面编程？ 需要在分析项目功能时，找出切面 合理的安排切面的执行时间（在目标方法前还是目标方法后） 合理安排切面执行的位置，在哪个类，那个方法增强功能 面试常问 说一下切面的关键要素 切面的功能代码，切面干什么 切面的执行位置，使用Pointcut表示切面执行的位置 切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后 学习aspectJ框架使用 切面的执行时间，这个执行时间在规范中叫做Advice（通知，增强）在aspectj框架使用注解表示的。也可以使用注解表示，也可以配置到xml文件中 @Befor @After @AfterReturning @AfterThrowing @Around AspectJ切入点表达式（重点） AspectJ定义了专门的表达式用于指定切入点。表达式的原型是： excution(modifiers-pattern ? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throw-pattern?) 解释 modifiers-pattern 访问权限类型 ret-type-pattern 返回值类型 declaring-type-pattern 包类型名 name-pattern(param-pattern) 方法名（参数类型和参数个数） throw-pattern 抛出异常类型 ？表示可选的部分 以上表达式共四个部分 execution（访问权限 方法返回值 方法声明(参数) 异常类型） ​ 切入点表达式要匹配的对象就是目标方法的方法名。所以，execution表达式中明显就是方法的签名。注意，表达式中黑色文字表述可省略部分，各部分间空格分开，在其中可以使用 举例 execution(public * *(..)) 指定切入点为：任意公共方法 execution(* set*(..)) 指定切入点为：任意一个以set开始的方法 execution(* com.xyz.service.*. *(..)) 指定切入点为：定义在service包里的任意类的任意方法 execution(* com.xyz.service..*. * (..)) 指定切入点为：指定所以包下的service包或者子包里的任意类的任意方法 execution(* ..service. * .(..)) 指定所以包下的service子包下的所有类（接口）中所有方法为切入点 案例以及说明1、创建Maven项目导入依赖123456789101112131415161718&lt;dependency&gt; &lt;!--spring依赖--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--测试类依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;!--aspectJ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 2、创建接口和真实对象 3、创建切面类123456789101112131415161718192021222324252627282930313233343536373839package com.zang.config;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;/*** @Aspect :是aspectj框架中的注解 * 作用：表示当前类是切面类 * 切面类：是用来给业务方法增加功能的类，在这个类中有切面功能的代码* 位置：在类定义之上 */@Aspectpublic class AnnotationPointcut &#123; /** * 定义方法，方法是实现切面功能的 * 方法定义的要求： * 1. 公共方法public * 2. 方法没有返回值 * 3. 方法名称自定义 * 4.方法可以有参数也可以没有参数 * 如果有参数，参数不是自定义的，有几个参数类型可以使用 */ /** * @Before: 前置注解 * 属性value，是切入点表达式，表示切面的功能执行在方法的位置 * * 特点： * 1. 在目标方法之前先执行的 * 2. 不会改变目标方法的执行结果 * 3. 不会影响目标方法的执行 */ @Before(&quot;execution(* com.zang.service.LoginServiceImpl.loginUser(..))&quot;) public void before()&#123; //你切面要执行的功能代码 System.out.println(&quot;方法执行前进行切入执行成功&quot;); &#125;&#125; 4、创建配置文件123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--把对象交给Spring容器，由spring容器统一创建，管理对象--&gt; &lt;!--声明目标对象--&gt; &lt;bean id=&quot;loginservice&quot; class=&quot;com.zang.service.LoginServiceImpl&quot;/&gt; &lt;!--声明切面类对象--&gt; &lt;bean id=&quot;pointcut&quot; class=&quot;com.zang.config.AnnotationPointcut&quot;/&gt; &lt;!--声明自动代理生成器：使用aspectj框架内部的功能，创建目标对象的代理对象 创建代理对象是在内存中实现的，修改目标对象在内存中的结构，创建为代理对象 所以真实对象就是被修改后的代理对象 aspectj-autoproxy:会把spring容器中的所有真实对象，一次性都生成代理对象 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 5、创建测试类进行测试","path":"2021/09/18/AOP/","date":"09-18","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"获取Field","text":"person.java 123456789package com.zang.demo;public class Person &#123; private String name=&quot;ys&quot;; public int id; protected int age; boolean sex;&#125; 我们这个实体类用不同关键词修饰 得到属性 此时测试一下 1234567@Test public void getName() throws ClassNotFoundException, NoSuchFieldException &#123; Class studentClass = Class.forName(&quot;com.zang.demo.Person&quot;); Field[] fields = studentClass.getFields(); System.out.println(fields.length);&#125; 结果是1，很明显getFields();方法只可以获得public公开的属性 下面我们使用getDeclaredFields(); 可以看到结果为4，说明他可以将四个属性都获取到 遍历一下getName()就获得属性的名字了 得到类型 由于上边使用的getName得到名字，所以我们可以猜想一下类型是不是getType() 我们发现是可以获得的 下面我们获取属性的修饰符列表 还是得猜，其实反射很简单好多都可猜出来 我们下面试一试 我们发现调用Modifiers返回int类型 应该可以感觉出每一个修饰符肯定对应一个数字 我们此时调用Modifier中的静态方法toString可以将数字转换为代表的修饰符","path":"2021/09/16/获取Field/","date":"09-16","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"回顾反射","text":"1、什么是反射机制？反射机制有啥用？ 反射机制可以操作字节码文件 作用：可以让程序更加灵活 2、反射机制相关的类在哪个包下？java.lang.reflact.* 3、反射机制相关的主要类java.lang.Class java.lang.reflect.Method//方法 java.lang.reflect.Comstructor//构造方法 java.lang.reflect.Field//属性 4、在java中获取Class的三种方式 Class.forName(); 对象.getClass(); 类型.class(); 5、获得了Class之后，可以调用无参构造方法来实例化对象name代表的就是Strdent类型 Class name=Class.forName(“com.zang.pojo.Student”); 一定要注意： name.newInstance();//底层调用无参构造方法 如果没有这个无参方法会出现异常 6、如果你只想让一个类的“静态代码块”执行的话可以怎么做呢？Class.forName()； 这样类就加载，类加载的时候，只有静态代码块执行 7、关于路径问题String path = Thread.currentThread().getContaxtClassLoader().getResource(“”).getPath(); 可以获取决定路径 但是该文件要求放在类路径下 该方法是为了获取一个文件的决定路径（不会受到环境移植的影响） 8、IO+Properties怎么快速绑定属性资源文件123456@Test public void getName()&#123; ResourceBundle db = ResourceBundle.getBundle(&quot;db&quot;); String name = db.getString(&quot;name&quot;); System.out.println(name);&#125;","path":"2021/09/15/回顾反射/","date":"09-15","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"聊一聊类加载器","text":"类加载器关于JDK中自带的类加载器 专门负责加载类的命令 JDK中自带了三个类加载器 启动加载器 扩展加载器 应用加载器 12345678910111213/** 假如有这样一串代码 String name=&quot;臧臧&quot;* 代码在开始执行之前会将需要的类全部加载到JVM中，* 通过类加载器加载，看到以上代码之后类加载器会找String.class文件找到就加载* 1. 首先通过类加载器进行加载* 1.1 启动类加载器专门加载C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\rt.jar rt.jar中都是JDK最核心的类库* 2. 通过启动类加载器加载不到的时候* 会通过扩展类加载器加载C:\\Program Files\\Java\\jdk1.8.0_144\\jre\\lib\\ext.jar* 3. 如果扩展类加载不到的话那么会通过应用加载类加载* 注意此时扩展类加载的是classpath（梦开始的地方）*** */ 双亲委派机制java中为了保证类加载的安全，使用了双亲委派机制 优先从启动类加载器中加载，这个成为“父”,当“父类”加载不到的时候再从扩展类加载器中加载，这个成为”母“，双亲委派，如果都加载不到才会考虑从应用类加载器中加载,直到加载到为止 就是假如我们自己写了一个String但是黑客在里边植入了一个病毒，恰巧我们使用了他，如果没有双亲委派机制的话类加载顺序混乱了恰巧加载到了我们自己的类没有加载到Sun公司的String，我们此时就被植入病毒了，所以需要双亲委派机制","path":"2021/09/15/聊一聊类加载器/","date":"09-15","excerpt":"","tags":[{"name":"反射","slug":"反射","permalink":"https://zangblog.gitee.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"使用JavaConfig实现配置","text":"基于Java类进行配置javaConfig原来是一个Spring的一个子项目，它通过Java类的方式提供Bean的定义信息，在Spring4的版本，JavaConfig已正式成为Spring4的核心功能，有两种方法 第一种 编写实体类 1234567891011121314151617181920212223242526272829package com.zang.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component//托管于Springpublic class User &#123; @Value(&quot;臧臧&quot;) private String name; @Value(&quot;99999&quot;) private int id; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 创建配置类Config 123456789101112package com.zang.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//这个注解其实相当于把这个类变成容器了@ComponentScan(&quot;com.zang.pojo&quot;)//扫描包public class Configer &#123;&#125; 测试 123456@Testpublic void testOne()&#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(User.class); User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user.getName());&#125; 根据结果得知这种方式可以将实体类托管于Spring中 第二种 创建实体类 12345678910111213141516171819202122232425262728package com.zang.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;public class User &#123; @Value(&quot;臧臧&quot;) private String name; @Value(&quot;99999&quot;) private int id; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 这个实体类就将@Component注解去掉使用另一种方法将其托管 创建配置类Configer 123456789101112131415package com.zang.config;import com.zang.pojo.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(&quot;com.zang.pojo&quot;)public class Configer &#123; @Bean public User getUser()&#123; return new User(); &#125;&#125; 测试 发现同样可以将数据取出来，所以有这两种方法下面我们都对其进行托管观察是否是同一个对象 通过测试发现并不是同一个对象，所以通过JavaConfig实现完全脱离xml文件的配置有这两种方法 导入其他配置如何做 再编写一个配置类 123@Configuration //代表这是一个配置类public class MyConfig2 &#123;&#125; 在之前的配置类中我们来选择导入这个配置类 12345678@Configuration@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig &#123;@Beanpublic Dog dog()&#123;return new Dog();&#125;&#125;","path":"2021/09/12/使用JavaConfig实现配置/","date":"09-12","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"代理模式","text":"因为AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 静态代理静态代理角色分析 抽象角色：一般使用接口或者抽象类来实现 真实角色：被代理的角色 代理角色：代理真实角色；代理真实角色后，一般会做一些附属的操作 客户：使用代理角色来进行一些操作 代码实现 Rent.java即抽象角色 12345package com.zang.dao;public interface Rent &#123; public void rent();&#125; Host.java真实角色 123456789package com.zang.dao;//真实角色房东，房东要出租房子public class Host implements Rent &#123; @Override public void rent() &#123; System.out.println(&quot;房屋出租&quot;); &#125;&#125; Proxy.java即代理角色 1234567891011121314151617181920212223package com.zang.dao;//代理对象，中介public class Proxy implements Rent &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host=host; &#125; @Override public void rent() &#123; seeHouse(); host.rent(); buy(); &#125; public void seeHouse()&#123; System.out.println(&quot;看房子&quot;); &#125; public void buy()&#123; System.out.println(&quot;买房子&quot;); &#125;&#125; Client.java客户 1234567public class Client &#123; public static void main(String[] args) &#123; Host host = new Host(); Proxy proxy = new Proxy(host); proxy.rent(); &#125;&#125; 分析： 在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧 租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更 加抽象的看待生活中发生的事情。 静态代理的好处 可以是我们的真实角色更加纯粹不再去关注一些公共的事情 公共的业务由代理来完成，实现了业务的分工， 公司业务发生扩展时变得更加集中和方便 缺点： 类多了，多了代理类，工作量大了，开发效率降低 我们想要静态代理的好处，又不想要静态代理的缺点，所以就有了动态代理！ 静态代理再理解 创建一个抽象角色，比如咱们平时做的用户业务，抽象起来就是增删改查 12345678package com.zang.service;public interface UserService &#123; void addUser(); void deleteUser(); void updateUser(); void query();&#125; 我们需要一个真实对象来完成这些增删改查操作 1234567891011121314151617181920212223package com.zang.service;public class UserServiceImpl implements UserService&#123; @Override public void addUser() &#123; System.out.println(&quot;添加一个用户&quot;); &#125; @Override public void deleteUser() &#123; System.out.println(&quot;删除一个用户&quot;); &#125; @Override public void updateUser() &#123; System.out.println(&quot;更新一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询一个用户&quot;); &#125;&#125; 需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1：在实现类上增加代码【麻烦】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的 设置一个代理类来处理日志！代理角色 12345678910111213141516171819202122232425262728293031323334353637package com.zang.service;public class Proxy implements UserService&#123; private UserServiceImpl userService; public Proxy(UserServiceImpl userService) &#123; this.userService = userService; &#125; @Override public void addUser() &#123; log(&quot;add&quot;); userService.addUser(); &#125; @Override public void deleteUser() &#123; log(&quot;delete&quot;); userService.deleteUser(); &#125; @Override public void updateUser() &#123; log(&quot;update&quot;); userService.updateUser(); &#125; @Override public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; public void log(String msg)&#123; System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); &#125;&#125; 测试访问类 1234567@Testpublic void testOne()&#123; UserServiceImpl userService = new UserServiceImpl(); Proxy proxy = new Proxy(userService); proxy.addUser();&#125; ==我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想== 动态代理 动态代理的角色和静态代理的一样 动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的 动态代理分为两类：一类是基于接口的动态代理，一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！ 反射机制复习请搜索文章回顾反射 JDK动态代理 反射：Method类，表示方法，类中的方法，通过Method可以执行某个方法 jdk动态代理的实现 反射包 java.lang.reflect 里面有三个类：invocationHandler，Method，Proxy 1）InvocationHander接口（调用处理器）：就一个方法invoke() ​ invoke()：表示代理对象要执行的功能代码，你的代理类要完成的功能就卸载invoke()方法中， public Object invoke(Object proxy,Method method,Object[] args) ​ Object proxy:jdk创建的代理对象，无需赋值 ​ Method method:目标类中的方法，执行目标方法的功能 ​ Object[] args:目标类中的方法参数 InvocationHander 接口：表示你的代理要干什么 ​ 怎么用：创建类实现接口InvocationHander ​ 重写invoke()方法，把原来静态代理中代理类要完成的功能，写在这 ​ 2）Method类：表示方法的，可以说就是目标类中的方法。 ​ 作用：通过Method可以执行某个目标类中的方法Method.invoke()； ​ Method.invoke(对象,方法的参数) ​ 3）Proxy类：核心的对象，创建代理对象，之前创建对象都是new类的构造方法() ​ 我们使用Proxy类中的方法代替new对象 newProxyInstance()作用是创建代理对象 ​ public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) ​ 参数： 1. ClassLoader loader 类加载器，负责向内存中加载对象的，使用反射获取 2. Class&lt;?&gt; [] interfaces:接口，目标对象实现的类加载器 3. InvocationHander h； 实现动态代理的步骤 创建接口，定义目标类要完成的事 123public interface UsbSell &#123; float sell(int amont);&#125; 创建目标类实现接口 123456789//真人public class UsbSellImpl implements UsbSell &#123; @Override public float sell(int amont) &#123; //目标方法 System.out.println(&quot;目标类执行了目标方法&quot;); return amont; &#125;&#125; 创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能 调用目标方法 增强功能 使用Proxy类的静态方法，创建代理对象，并把返回值转为接口类型","path":"2021/09/12/代理模式/","date":"09-12","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"使用注解","text":"1、说明在Spring4之后，想要使用注解形式，必须要引入aop的包 在配置文件中，还得要引入一个context约束 12345678&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot; default-autowire=&quot;byType&quot;&gt; 2、Bean的实现我们之前都是使用bean的标签进行bean注入，但是实际开发中我们一般都会使用注解！ 配置扫描哪些包下的注解 12&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt; 在指定包下编写类，增加注解 12345678@Component(&quot;user&quot;)public class User &#123; private String name=&quot;zz&quot;; public String getName() &#123; return name; &#125;&#125; 测试 123456@Testpublic void getUser()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user.getName());&#125; 3、属性注入使用注解注入属性 可以不用set方法直接在名上添加@value（”值”） 1234567@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123;@Value(&quot;秦疆&quot;)// 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;臧臧&quot;/&gt;public String name;&#125; 如果提供了set方法，在set方法上添加@value(“值”) 12345678@Component(&quot;user&quot;) public class User &#123; public String name; @Value(&quot;臧臧&quot;) public void setName(String name) &#123; this.name = name; &#125; &#125; 4、衍生注解我们这些注解，就是代替了在配置文件当中配置步骤而已！更加方便快捷！ @Component三个衍生注解 为了更好的分层，Spring可以使用其他三个注解，功能一样，目前使用哪个都一样 @Controller：web层 Service：service层 Repositor：dao层 写上这个注解，就相当于这个类交给Spring管理装配了！ 5、作用域@scope singleton：默认的，Spring会才填单例模式创建这个对象，关闭工厂，所有的对象都会销毁。 prototype：多例模式，关闭工厂，所有的对象不会销毁。内部的垃圾回收机制会回放 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123;@Value(&quot;秦疆&quot;)public String name;&#125; 6、小结XML与注解比较 XML可以适用任何场景，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 XML与注解整合开发 xml整理Bean 注解完成属性注入 使用过程中，可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！","path":"2021/09/11/使用注解/","date":"09-11","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"Bean的自动装配","text":"自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean Spring中bean有三种装配机制，分别是： 在xml中显示配置 在java中显示配置 隐式的bean发现机制和自动装配 我们说一下第三种:自动化装配bean。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使的显示的配置降低到最少。 ==推荐不使用自动装配xml配置 , 而使用注解== 1、测试环境搭建 新建一个项目 新建两个实体类 Cat Dog都有一个叫的方法 1234567package com.zang.pojo;public class Cat &#123; public void getCall()&#123; System.out.println(&quot;miao~~&quot;); &#125;&#125; 1234567package com.zang.pojo;public class Dog &#123; public void getCall()&#123; System.out.println(&quot;汪汪&quot;); &#125;&#125; 新建一个学生类Student 12345678910111213141516171819202122232425262728293031323334353637383940package com.zang.pojo;public class Student &#123; private String name; private Cat cat; private Dog dog; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, cat=&quot; + cat + &quot;, dog=&quot; + dog + &#x27;&#125;&#x27;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125; 编写Spring配置文件 123456789&lt;bean id=&quot;student&quot; class=&quot;com.zang.pojo.Student&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;臧臧&quot;/&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;&lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.zang.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.zang.pojo.Dog&quot;/&gt;&lt;/beans&gt; 测试 正常环境ok 2、byNameautowire byName(按名称自动装配) 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率 降低。 采用自动装配将避免这些错误，并且使配置简单化。 测试 修改bean配置，增加一个属性 再次测试，结果依旧输出成功 我们将cat的bean改为cat*** 再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方 法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结 当一个bean节点带有autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 3、byTypeautowire byType (按类型自动装配) 使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一 的异常。 1NoUniqueBeanDefinitionException 测试: 将User的bean配置改一下：autowire=”byType” 测试正常输出 再注册一个cat的bean对象！ 123456&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt;&lt;property name=&quot;str&quot; value=&quot;zz&quot;/&gt;&lt;/bean&gt; 测试，报错：NoUniqueBeanDefinitionException 删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后 的结果。甚至将id属性去掉，也不影响结果。 4、使用注解jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作： 利用注解的方式注入属性。 在spring配置文件中引入context文件头 123xmlns:context=&quot;http://www.springframework.org/schema/context&quot;http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 开启注解支持 1&lt;context:annotation-config/&gt; 4.1、@Autowired @Autowired是按类型自动装配的，不支持id匹配 需要导入spring-aop的包 将User类中是set方法去掉，使用@Autowired注解 12345678910111213141516public class User &#123;@Autowiredprivate Cat cat;@Autowiredprivate Dog dog;private String str;public Cat getCat() &#123;return cat;&#125;public Dog getDog() &#123; return dog;&#125;public String getStr() &#123; return str; &#125;&#125; 此时配置文件内容 1234&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 测试成功 4.2@Qualifier Autowired是根据数据类型自动装配的，加上Qualifer则可以在如果有两个相同类型的时候id不一样就可以使用@Qualifier不能单独使用 测试实验步骤： 配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 1234&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 没有加Qualifier测试，直接报错 在属性上添加Qualifier注解 123456@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog; 测试，成功输出 4.3、@Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User &#123;//如果允许对象为null，设置required = false,默认为true@Resource(name = &quot;cat2&quot;)private Cat cat;@Resourceprivate Dog dog;private String str;&#125; beans.xml 1234&lt;bean id=&quot;dog&quot; class=&quot;com.zang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.zang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.zang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.zang.pojo.User&quot;/&gt; 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 实体类上只保留注解 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 结果成功 结论：先进行byName查找，失败；再进行byType查找，成功。 @Autowired与Resource异同 @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果 要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我 们想使用名称装配可以结合@Qualifier注解进行使用 @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果 没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在 setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是 需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先 byName。","path":"2021/09/11/Bean的自动装配/","date":"09-11","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"依赖注入(DI)","text":"依赖注入(Dl) 依赖注入(Deprndency Injection，DI) 依赖：指Bean对象的创建依赖于容器 注入：指Bean对象所以来的资源由容器来设置和装配 1、构造器注入之前说过 2、set注入(重点)要求被注入的属性，必须有set方法，set方法的方法名由set+属性首字母大写，如果属性是boolean类型，没有set方法，是is。 测试pojo类 12345678910111213package com.zang.pojo;public class Adress &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.zang.pojo;import java.util.*;public class Student &#123; private String name; private Adress adress; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, adress=&quot; + adress + &quot;, books=&quot; + Arrays.toString(books) + &quot;, hobbies=&quot; + hobbies + &quot;, card=&quot; + card + &quot;, games=&quot; + games + &quot;, wife=&#x27;&quot; + wife + &#x27;\\&#x27;&#x27; + &quot;, info=&quot; + info + &#x27;&#125;&#x27;; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAdress(Adress adress) &#123; this.adress = adress; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public void setHobbies(List&lt;String&gt; hobbies) &#123; this.hobbies = hobbies; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; public String getName() &#123; return name; &#125; public Adress getAdress() &#123; return adress; &#125; public String[] getBooks() &#123; return books; &#125; public List&lt;String&gt; getHobbies() &#123; return hobbies; &#125; public Map&lt;String, String&gt; getCard() &#123; return card; &#125; public Set&lt;String&gt; getGames() &#123; return games; &#125; public String getWife() &#123; return wife; &#125; public Properties getInfo() &#123; return info; &#125;&#125; 常量注入 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.zang.pojo.Student&quot; id=&quot;student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小臧&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 12345@Test public void testOne()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Student student = context.getBean(&quot;student&quot;, Student.class); System.out.println(student.getName()); Bean注入 ==这里的值是一个引用，ref== 123456&lt;bean id=&quot;adress&quot; class=&quot;com.zang.pojo.Adress&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;雄安&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.zang.pojo.Student&quot;&gt; &lt;property name=&quot;adress&quot; ref=&quot;adress&quot;/&gt;&lt;/bean&gt; 数组注入 12345678910&lt;bean id=&quot;student&quot; class=&quot;com.zang.pojo.Student&quot;&gt; &lt;property name=&quot;books&quot; &gt; &lt;array &gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; List注入 12345678&lt;bean id=&quot;student&quot; class=&quot;com.zang.pojo.Student&quot;&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;学习&lt;/value&gt; &lt;value&gt;打乒乓球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; Map注入 12345678&lt;bean id=&quot;student&quot; class=&quot;com.zang.pojo.Student&quot;&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;臧臧&quot; value=&quot;zzz&quot;/&gt; &lt;entry key=&quot;zzz&quot; value=&quot;zsl&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; set注入 12345678&lt;bean class=&quot;com.zang.pojo.Student&quot; id=&quot;student&quot;&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;QQflycar&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; Null注入 12345&lt;bean id=&quot;student&quot; class=&quot;com.zang.pojo.Student&quot;&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; Properties注入 1234567&lt;bean id=&quot;student&quot; class=&quot;com.zang.pojo.Student&quot;&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;zz&quot;&gt;xx&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 测试结果 Student{name=’小臧’, adress=Adress{address=’雄安’}, books=[西游记, 红楼梦, 水浒传, 三国演义], hobbies=[学习, 打乒乓球], card={臧臧=zzz, zzz=zsl}, games=[LOL, QQflycar], wife=’null’, info={zz=xx}} 3、扩展注入实现User.java： 1234567891011121314151617public class User &#123;private String name;private int age;public void setName(String name) &#123;this.name = name;&#125;public void setAge(int age) &#123;this.age = age;&#125;@Overridepublic String toString() &#123;return &quot;User&#123;&quot; +&quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +&quot;, age=&quot; + age +&#x27;&#125;&#x27;;&#125;&#125; P命名空间注入 : 需要在头文件中假如约束文件 123导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;臧臧&quot; p:age=&quot;18&quot;/&gt; c 命名空间注入 : 需要在头文件中假如约束文件 123导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt; 发现问题：爆红了，刚才我们没有写有参构造！ 解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！","path":"2021/09/10/依赖注入-DI/","date":"09-10","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"Spring配置","text":"我们可以很明显看到Spring的配置比MyBatis少很多 alias起别名 12&lt;!--&lt;alias name=&quot;&quot; name为bean的id, alias=&quot;&quot;alias为别名--&gt;&lt;alias name=&quot;userT2&quot; alias=&quot;t&quot;/&gt; import 团队的合作通过import来实现 1&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;","path":"2021/09/09/Spring配置/","date":"09-09","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"IOC创建对象的方式","text":"IOC创建对象的方式1、通过无参构造方法来创建 User.java 123456789101112131415161718package com.zang.pojo;public class User &#123; private String name; public User()&#123; System.out.println(&quot;User的无参构造&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+name); &#125;&#125; Beans.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--创建User类对应的bean，对其进行注册--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.zang.pojo.User&quot;&gt; &lt;!--set方法--&gt; &lt;property name=&quot;name&quot; value=&quot;臧臧&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 根据结果我们此时已经知道了，在调用show之前已经通过了无参构造创建了对象 2、通过有参方法来创建我们都知道只要有了有参方法，我们默认的无参方法就会失效如果需要需要自己重写 UserT 1234567891011121314151617181920package com.zang.pojo;public class UserT &#123; private String name; public UserT(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+name); &#125;&#125; Beans.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--通过下标创建对象--&gt; &lt;bean id=&quot;userT&quot; class=&quot;com.zang.pojo.UserT&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;臧臧&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 1234&lt;!--通过类型创建对象--&gt;&lt;bean id=&quot;userT2&quot; class=&quot;com.zang.pojo.UserT&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;臧臧&quot;/&gt;&lt;/bean&gt; 1234&lt;!--通过名字创建对象--&gt;&lt;bean id=&quot;userT3&quot; class=&quot;com.zang.pojo.UserT&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;臧臧&quot;/&gt;&lt;/bean&gt; 这就是3种通过有参创建对象的方法 现在我们将xml改一下，将User扔进容器里，但是我们不去getbean获取它 此时我们会发现我们并没有getBean，但是还是创建了User的对象所以得出结论 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！","path":"2021/09/09/IOC创建对象的方式/","date":"09-09","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"HelloSpring","text":"创建spring1、导入依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--测试junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 2、创建pojo实体类12345678910111213141516171819202122232425262728public class User &#123; private String name; private String sex; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 3、创建容器Beans.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--创建User类对应的bean，对其进行注册--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.zang.pojo.User&quot;&gt; &lt;!--set方法--&gt; &lt;property name=&quot;name&quot; value=&quot;臧臧&quot;/&gt; &lt;property name=&quot;sex&quot; value=&quot;男&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 4、进行测试12345678@Test public void tes()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Object user = context.getBean(&quot;user&quot;); //getBean : 参数即为spring配置文件中bean的id System.out.println(user.toString()); &#125; 自我理解：springbean容器即一个盒子，现在ioc思想即之前是由程序员对方法进行控制，现在是程序员将所有方法以及对象都放在bean容器中，现在由客户去取，程序员由主动变成了被动，客户为主动，即为控制反转。 思考 Hello 对象是谁创建的 ? 【 hello 对象是由Spring创建的 】 Hello 对象的属性是怎么设置的 ? 【hello 对象的属性是由Spring容器设置的 】 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是 由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 依赖注入 : 就是利用set方法来进行注入的. ==IOC是一种编程思想，由主动的编程变成被动的接收== 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 1、修改案例我们在案例1中新增了一个Spring.xml配置文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--创建User类对应的bean，对其进行注册--&gt; &lt;!--注册Userdao实现类--&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.zang.dao.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userSqlImpl&quot; class=&quot;com.zang.dao.UserSqlImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.zang.service.UserServiceImpl&quot;&gt; &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt; &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试1234567@Test public void testOne()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserServiceImpl userService =(UserServiceImpl) context.getBean(&quot;userService&quot;); userService.getUser();&#125; OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !","path":"2021/09/08/HelloSpring/","date":"09-08","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"IoC基础","text":"新建一个Maven空白项目 1、创建一个接口UserDao 123public interface UserDao &#123; void getUser();&#125; 2、创建一个实现类UserDaoImpl 123456public class UserDaoImpl implements UserDao&#123; @Override public void getUser() &#123; System.out.println(&quot;我是臧臧&quot;); &#125;&#125; 3、然后写UserService接口UserService 123public interface UserService &#123; void getUser();&#125; 4、创建UserServiceImpl实现类UserServiceImpl 1234567public class UserServiceImpl implements UserService&#123; private UserDao userDao = new UserDaoImpl(); public void getUser() &#123; //service层调用dao层方法 userDao.getUser(); &#125;&#125; 5、创建测试类进行测试1234567public class TT &#123; @Test public void oo()&#123; UserService userService = new UserServiceImpl(); userService.getUser(); &#125;&#125; 这是我们正常的使用，但是现在问题来了，客户要求我们增加一个Sql功能，我们此时不仅要重新写一个dao层的接口实现类而且还有改变service层调用的方法 123456public class UserSqlImpl implements UserDao&#123; @Override public void getUser() &#123; System.out.println(&quot;我是SQL&quot;); &#125;&#125; 123456public class UserServiceImpl implements UserService&#123; private UserDao userDao = new UserSqlImpl(); public void getUser() &#123; userDao.getUser(); &#125;&#125; 此时我们再增加一个方法Mybatis，还要写dao和改service每次这样就有点变态了，每次变动都要修改大量的代码， 那么这种问题怎么解决呢， 我们可以在需要用到他的地方不去实现它，而是留一个接口，利用set，我们区代码修改一下 1234567891011public class UserServiceImpl implements UserService&#123; private UserDao userDao; //利用set 方法 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void getUser() &#123; userDao.getUser(); &#125;&#125; 我们现在测试下 123456789@Test public void oo()&#123; UserServiceImpl userService = new UserServiceImpl(); userService.setUserDao(new UserDaoImpl()); userService.getUser(); //现在我们又想用Sql实现直接利用我们流出来的那个口使用set就可以了 userService.setUserDao(new UserSqlImpl()); userService.getUser(); &#125; 大家发现了区别没有 ? 可能很多人说没啥区别 . 但是 , 他们已经发生了根本性的变化 , 很多地方都 不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对 象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 . 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合 性大大降低 . 这也就是IOC的原型 ! Ioc本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认 为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系 完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为 所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解， 新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用 时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为 一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现 控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。","path":"2021/09/08/IoC基础/","date":"09-08","excerpt":"","tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"}]},{"title":"缓存","text":"缓存1、简介 什么是缓存？ 存在内存中的临时数据 将用户经常查询的数据存放在缓存（内存）中，用户去查询数据就能不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据能使用缓存 经常查询并且不经常改变的数据 2、MyBatis缓存 MyBatis包含一个非常强大的查询缓存特性，他可以非常方便的定制和配置缓存，缓存可以极大的提升查询效率 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存 为了提高扩展性，Myabtis定义了缓存接口Cache，我们可以通过实现Cache接口来定义二级缓存 3、一级缓存 一级缓存又称本地缓存 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去数据库查询 3.1、初体验测试 在mybatis中加入日志，方便测试结果 编写接口类 1User getUser(@Param(&quot;id&quot;) int id); 编写接口对应的Mapper文件 123&lt;select id=&quot;getUser&quot; parameterType=&quot;_int&quot; resultType=&quot;com.zang.pojo.User&quot; &gt; select * from user where id= #&#123;id&#125;&lt;/select&gt; 测试 1234567891011@Testpublic void cache()&#123; SqlSession session = UGetSQLSession.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.getUser(1); System.out.println(user); User user1 = mapper.getUser(1); System.out.println(user1); System.out.println(user==user1); session.close();&#125; 可以发现sql语句只查询了一次 第二次结果，没有进行数据库查询 而且用的是同一个对象 3.2、一级缓存失效的四种情况 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！ sqlSession不同 123456789101112@Testpublic void cache()&#123; SqlSession session = UGetSQLSession.getSession(); SqlSession session1 = UGetSQLSession.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper1 = session1.getMapper(UserMapper.class); User user = mapper.getUser(1); System.out.println(user); User user1 = mapper1.getUser(1); System.out.println(user==user1); session.close();&#125; 观察结果：发现发送了两条SQL语句！ 结论：每个sqlSession中的缓存相互独立 sqlSession相同，查询条件不同 1234567891011@Testpublic void cache()&#123; SqlSession session = UGetSQLSession.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.getUser(1); User user1 = mapper.getUser(2); System.out.println(user==user1); session.close();&#125; sqlSession相同，两次查询之间执行了增删改操作！ 编写方法 1int addUser(Map map); 编写mapper.xml 123&lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt; insert into user (id,name,pwd) value (id=#&#123;id&#125;,name=#&#123;name&#125;,pwd=#&#123;pwd&#125;)&lt;/insert&gt; 测试 1234567891011121314@Test public void addUser()&#123; SqlSession session = UGetSQLSession.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.getUser(1); System.out.println(user); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;,9); map.put(&quot;name&quot;,&quot;臧&quot;); map.put(&quot;pwd&quot;,&quot;999999&quot;); mapper.addUser(map); User user1 = mapper.getUser(1); System.out.println(user1); &#125; 观察结果：查询在中间执行了增删改操作后，重新执行了 结论：因为增删改操作可能会对当前数据产生影响 sqlSession相同，手动清除一级缓存 123456789101112@Testpublic void testQueryUserById()&#123;SqlSession session = MybatisUtils.getSession();UserMapper mapper = session.getMapper(UserMapper.class);User user = mapper.queryUserById(1);System.out.println(user);session.clearCache();//手动清除缓存User user2 = mapper.queryUserById(1);System.out.println(user2);System.out.println(user==user2);session.close();&#125; 4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存; 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的以及缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存(map)中； 开启全局缓存[mybatis-config.xml] 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 去每个mapper.xml中配置使用二级缓存，这个配置非常简单； 123456789&lt;cache/&gt; &lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;&lt;!--这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。--&gt; 测试 所有的实体类先实现序列化接口 测试代码 123456789101112131415@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();&#125; 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中","path":"2021/09/07/缓存/","date":"09-07","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"如何打开知网下载文件","text":"第一步、进入知网官网，下载CAJViewer 这是官网:http://cajviewer.cnki.net 进去之后 点这下载，下载结束傻瓜式安装我就不给你说了奥 第二部进入该软件，点击文件- 打开-选择你要打开的caj文件 然后找到你的文件下载位置就好了","path":"2021/09/07/如何打开知网下载文件/","date":"09-07","excerpt":"","tags":[{"name":"技巧","slug":"技巧","permalink":"https://zangblog.gitee.io/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"动态SQL","text":"搭建环境1234567CREATE TABLE blog( `id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;, `title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;, `author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;, `create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;, `view` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8 1、创建一个基础工程 导包 编写配置文件 编写实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.zang.pojo;import java.util.Date;public class Blog &#123; private String id; private String title; private String author; private Date createTime; private int views; @Override public String toString() &#123; return &quot;Blog&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, title=&#x27;&quot; + title + &#x27;\\&#x27;&#x27; + &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, createTime=&quot; + createTime + &quot;, views=&quot; + views + &#x27;&#125;&#x27;; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public int getViews() &#123; return views; &#125; public void setViews(int views) &#123; this.views = views; &#125; public Blog(String id, String title, String author, Date createTime, int views) &#123; this.id = id; this.title = title; this.author = author; this.createTime = createTime; this.views = views; &#125; public Blog() &#123; &#125;&#125; 编写实体类对应Mapper接口和Mapper.xml if语句需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之则根据作者名查询。 编写接口类 1List&lt;Blog&gt; queryBlogIf(Map map); 编写Mapper.xml文件 12345678910111213&lt;select id=&quot;queryBlogIf&quot; resultType=&quot;com.zang.pojo.Blog&quot; parameterType=&quot;map&quot;&gt; &lt;!--本来静态查询应该是这样然后我们动态SQL要使用标签if--&gt; select * from blog where author=#&#123;author&#125; and title=#&#123;title&#125; &lt;!--动态sql编写--&gt; select * from blog where &lt;if test=&quot;title != title&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != author&quot;&gt; and author=#&#123;author&#125; &lt;/if&gt; &lt;/select&gt; 进行测试 12345678910111213@Testpublic void queryBlogIf()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;title&quot;,&quot;Myabtis简单的很&quot;); List&lt;Blog&gt; blogs = mapper.queryBlogIf(map); sqlSession.close(); System.out.println(blogs);&#125; 此时有一个问题如果title为null的时候会报错，因为此时的SQL语句为select * from blog where and author=#{author}，这是就是错误的。那么我们应该怎么解决呢！ Where修改上面SQL的语句 1234567891011&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;com.zang.pojo.Blog&quot;&gt; select * from blog where &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个where标签会知道如果它包含的标签中有返回值的话，它就插入一个where。此外，如果标签返回值的内容是以AND或OR 开头的，他会自动剔除掉 Set同理，如果我们对于查询SQL语句包含where关键字，如果在进行更新操作的时候，含有set关键字，我们要怎么处理 编写接口方法 1int updateBlog(Map map); 编写对应的Mapper.xml文件 12345678910111213&lt;!--注意update中set是用逗号隔开--&gt;&lt;update&gt; update blog &lt;set&gt; &lt;if test=&quot;title!=null&quot;&gt; title=#&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; author=#&#123;author&#125; &lt;/if&gt; where id=#&#123;id&#125; &lt;/set&gt;&lt;/update&gt; 测试 123456789101112@Test public void updateBlog()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;title&quot;,&quot;Java世界第一&quot;); map.put(&quot;author&quot;,&quot;xxl&quot;); map.put(&quot;id&quot;,&quot;9207ee94acfa49b4b170587c1be9a227&quot;); mapper.updateBlog(map); sqlSession.commit(); sqlSession.close(); &#125; Choose有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用choose标签可以解决此类问题，类似我们Java的switch语句 编写接口方法 1List&lt;Blog&gt; queryBlogChoose(Map map); 编写对应的Mapper.xml 12345678910111213141516&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultMap=&quot;aa&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title!=null&quot;&gt; title=#&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author!=null&quot;&gt; and author=#&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and view=#&#123;view&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 测试 123456789101112@Testpublic void queryBlogChoose()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;view&quot;,99999); List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map); for (Blog blog : blogs) &#123; System.out.println(blog); &#125; sqlSession.close();&#125; SQL片段有的时候我们可能会有某个sql语句使用的很多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用 ==提取SQL片段== 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title!=null&quot;&gt; title=#&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author!=null&quot;&gt; and author=#&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; ==引用SQL片段== 123456&lt;select id=&quot;queryBlogChoose&quot; resultType=&quot;com.zang.pojo.Blog&quot; parameterType=&quot;map&quot;&gt; select * from blog &lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; ①、最好基于 单表来定义 sql 片段，提高片段的可重用性 ②、在 sql 片段中不要包括 where Foreach将数据库中前三个数据的id修改为1,2,3； 需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息 编写接口 1List&lt;Blog&gt; queryBlogForeach(Map map); 编写SQL语句 1234567891011121314151617&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;com.zang.pojo.Blog&quot;&gt;select * from blog&lt;where&gt;&lt;!--collection:指定输入对象中的集合属性item:每次遍历生成的对象open:开始遍历时的拼接字符串close:结束时拼接的字符串separator:遍历对象之间需要拼接的字符串select * from blog where 1=1 and (id=1 or id=2 or id=3)--&gt;&lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot;separator=&quot;or&quot;&gt;id=#&#123;id&#125;&lt;/foreach&gt;&lt;/where&gt;&lt;/select&gt; 测试 1234567891011121314@Testpublic void testQueryBlogForeach()&#123;SqlSession session = MybatisUtils.getSession();BlogMapper mapper = session.getMapper(BlogMapper.class);HashMap map = new HashMap();List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();ids.add(1);ids.add(2);ids.add(3);map.put(&quot;ids&quot;,ids);List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);System.out.println(blogs);session.close();&#125; 小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生 的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它 的技巧","path":"2021/09/06/动态SQL/","date":"09-06","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"设计模式概述","text":"","path":"2021/09/05/设计模式概述/","date":"09-05","excerpt":"","tags":[]},{"title":"一对多处理","text":"一对多的理解： 一个老师拥有多个学生 如果对于老师这边，就是一个一对多的现象 按结果嵌套处理1、创建接口方法1234public interface TeacherMapper &#123; public List&lt;Teacher&gt; getTeacher(); public Teacher getTeacherOne(@Param(&quot;tid&quot;) int id);&#125; 2、编写对应的mapper.xml123456789101112&lt;select id=&quot;getTeacherOne&quot; resultMap=&quot;tt&quot;&gt; select t.id tid,t.name tname,s.tid stid,s.id sid,s.name sname from teacher t ,student s where t.id=s.tid and t.id=#&#123;tid&#125; &lt;/select&gt; &lt;resultMap id=&quot;tt&quot; type=&quot;com.zang.pojo.Teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;id property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;com.zang.pojo.Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;id property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;id property=&quot;tid&quot; column=&quot;stid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 3、到配置文件mybatis-config.xml文件将mapper进行注册4、测试12345678@Testpublic void aVoidOne()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); Teacher teacherOne = mapper.getTeacherOne(1); System.out.println(teacherOne); sqlSession.close();&#125; 小结 关联-association 集合-collection 所以association是用于一对一和多对一，而collection是用于一对多的关系 JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 注意说明 保证SQL的可读性，尽量通俗易懂 根据实际要求，尽量编写性能更高的SQL语句 注意属性名和字段不一致的问题 注意一对多和多对一 中：字段和属性对应的问题 尽量使用Log4j，通过日志来查看自己的错误","path":"2021/09/05/一对多处理/","date":"09-05","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"多对一处理","text":"多对一理解： 多个学生在教室上课只有一个老师 如果对于有学生这边，就是一个多对一的现象，即从学生这边关联一个老师（这时在实体类中创建的老师类应该在学生里边在多的一方） 环境搭建1、创建数据库1234567891011121314151617181920create table `teacher` (`id` int(20) not null,`name` varchar(20) default null,primary key (`id`))engine=INNODB default charset=utf8insert into teacher (id,name) value (1,&#x27;臧臧&#x27;)create table `student`(`id` int(20) not null ,`name` varchar(20) default null,`tid` INT(10) DEFAULT NULL,PRIMARY KEY (`id`),KEY `fktid` (`tid`),CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8insert into `student` (id,name,tid) values(1,&#x27;小红&#x27;,&#x27;1&#x27;),(2,&#x27;小篮&#x27;,&#x27;1&#x27;),(3,&#x27;小紫&#x27;,&#x27;1&#x27;),(4,&#x27;小白&#x27;,&#x27;1&#x27;) 2、创建对应的实体类#### 2.1这里使用Lombok idea安装Lombok插件 引入Maven依赖 12345&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt; 在代码中增加注解 12345@Data //GET,SET,ToString，有参，无参构造public class Teacher &#123;private int id;private String name;&#125; 1234567@Datapublic class Student &#123;private int id;private String name;//多个学生可以是同一个老师，即多对一private Teacher teacher;&#125; 编写实体类对应的Mapper接口 无论有没有需求都应该写上 编写Mapper接口对应的xml配置文件 按照结果嵌套处理1、编写接口方法123public interface StudentMapper &#123; public List&lt;Student&gt; getStudent();&#125; 2、编写接口对应的mapper文件12345678910111213141516&lt;mapper namespace=&quot;com.zang.dao.StudentMapper&quot;&gt; &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; &lt;!--这里每一个都要起别名做结果集映射--&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;com.zang.pojo.Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;id property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;!--对应一个java类，然后对应这个类中的哪个属性--&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;com.zang.pojo.Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 3、去mybatis-config.xml中去注册4、测试123456789101112public class TestManyOne &#123; @Test public void getStudent()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; student = mapper.getStudent(); for (Student student1 : student) &#123; System.out.println(&quot;学生名：&quot;+student1.getName()+&quot;老师名:&quot;+student1.getTeacher().getName()); &#125; sqlSession.commit(); &#125;&#125; 按照查询嵌套处理1、给接口增加方法1public List&lt;Student&gt; getStudents(); 2、编写对应的mapper文件123456789&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeachers&quot;&gt; select * from student &lt;/select&gt; &lt;resultMap id=&quot;StudentTeachers&quot; type=&quot;com.zang.pojo.Student&quot;&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;com.zang.pojo.Teacher&quot; select=&quot;aa&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;aa&quot; resultType=&quot;com.zang.pojo.Teacher&quot;&gt; select* from teacher where id=#&#123;id&#125; &lt;/select&gt; 3、去mybatis-config.xml中注册4、注意点12345678910111213141516&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;&lt;association property=&quot;teacher&quot; column=&quot;&#123;id=tid,name=tid&#125;&quot;javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;!--这里传递过来的id，只有一个属性的时候，下面可以写任何值association中column多参数配置：column=&quot;&#123;key=value,key=value&#125;&quot;其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。--&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 5、测试12345678910@Test public void getStudent()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; student = mapper.getStudents(); for (Student student1 : student) &#123; System.out.println(student1); &#125; sqlSession.commit(); &#125;","path":"2021/09/05/多对一处理/","date":"09-05","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"注解增删改查","text":"查询 编写接口方法注解 123//查询所有用户@Select(&quot;select * from user&quot;)public List&lt;User&gt; getUser(); 测试 12345678@Testpublic void getUser()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); Mapper mapper = sqlSession.getMapper(Mapper.class); List&lt;User&gt; user = mapper.getUser(); for (User user1 : user) &#123; System.out.println(user1); &#125; 新增 编写接口方法注解 123//插入数据@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)public int insertUser(Map&lt;String,Object&gt; map); 测试 1234567891011public void insertUser()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); Mapper mapper = sqlSession.getMapper(Mapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;,9); map.put(&quot;name&quot;,&quot;zzzzz&quot;); map.put(&quot;pwd&quot;,&quot;99999&quot;); int i = mapper.insertUser(map); sqlSession.commit(); sqlSession.close();&#125; 修改 编写接口方法注解 123//更新数据@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;&quot;)public int updateUser(Map&lt;String,Object&gt; map); 测试 123456789101112@Test public void updateUser()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); Mapper mapper = sqlSession.getMapper(Mapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;,9); map.put(&quot;name&quot;,&quot;zxxxz&quot;); map.put(&quot;pwd&quot;,&quot;99999&quot;); mapper.updateUser(map); sqlSession.commit(); sqlSession.close(); &#125; 删除 编写接口方法注解 123//删除数据@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)public int deleteUser(@Param(&quot;id&quot;) int id); 测试 12345678@Testpublic void deleteUser()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); Mapper mapper = sqlSession.getMapper(Mapper.class); int i = mapper.deleteUser(9); sqlSession.commit(); sqlSession.close();&#125;","path":"2021/09/01/注解增删改查/","date":"09-01","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"利用注解开发","text":"利用注解开发 mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了 新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映 射并不能用注解来构建 sql 类型主要分成 : @select() @update() @Insert() @delete 利用注解开发就不需要mapper.xml文件了 我们在我们的接口中添加注解 123//查询全部用户@Select(&quot;select id,name,pwd password from user&quot;)public List&lt;User&gt; getAllUser(); 在mybatis的核心配置文件中注入 1234&lt;!--使用class绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.zang.dao.Mapper&quot;/&gt;&lt;/mappers&gt; 测试 123456789101112@Testpublic void testGetAllUser() &#123; SqlSession session = MybatisUtils.getSession();//本质上利用了jvm的动态代理机制 UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.getAllUser(); for (User user : users)&#123; System.out.println(user); &#125; session.close(); &#125; 利用debug查看本质 本质利用了JVM动态代理机制 Mybatis详细执行过程","path":"2021/09/01/利用注解开发/","date":"09-01","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://zangblog.gitee.io/tags/Mybatis/"}]},{"title":"limit实现分页","text":"为什么需要分页？ 在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查 询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对 数据库压力就在可控范围内。 使用Limit实现分页 12345678#语法SELECT * FROM table LIMIT stratIndex，pageSizeSELECT * FROM table LIMIT 5,10; // 检索记录行 6-15#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.#如果只给定一个参数，它表示返回最大的记录行数目：SELECT * FROM table LIMIT 5; //检索前 5 个记录行#换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤 修改Mapper文件 123&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; Mapper接口，参数为map 12//选择全部用户实现分页List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map); 在测试类中传入参数 推断：起始位置 = （当前页面 - 1 ） * 页面大小 1234567891011121314151617//分页查询 , 两个参数startIndex , pageSize@Testpublic void testSelectUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int currentPage = 1; //第几页 int pageSize = 2; //每页显示几个 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize); map.put(&quot;pageSize&quot;,pageSize); List&lt;User&gt; users = mapper.selectUser(map); for (User user: users)&#123; System.out.println(user); &#125; session.close(); &#125;","path":"2021/09/01/limit实现分页/","date":"09-01","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"Log4j日志","text":"什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件.GUI组件 我们也可以控制每一条日志的输出格式; 通过定义每一条日志信息的级别,我们能够更加细致地控制日志的生成过程。通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 123456&lt;!--Log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 在程序中直接使用Log4j进行输出 1234567891011public void testLog()&#123; SqlSession sqlSession = UtilSqlSession.getSqlSession(); Mapper mapper = sqlSession.getMapper(Mapper.class); User userById = mapper.getUserById(1); System.out.println(userById); logger.info(&quot;111&quot;); logger.debug(&quot;222&quot;); sqlSession.close();&#125; 测试 可以在我们配置的那个目录下对日志进行查看","path":"2021/09/01/Log4j日志/","date":"09-01","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"ResultMap结果集映射","text":"我们有的时候在真实项目往往会遇到一些问题 比如你数据库的的字段和实体类的名字并不是一样的此时就会遇到一个 问题，比如我们去根据一个id查询用户时，数据库中的字段是pwd，而实体类中是password此时去查就会发现 查询结果中password为null 我们要分析一下原因，因为sql语句是这样写的 但是这条sql语句就相当于 select id,name,password from….. 因为我们数据库中并没有password这一列所以结果为null 解决办法1、起别名为列名指定别名 , 别名和java实体类的属性名一致 . 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;select id,name,pwd as password from user where id = #&#123;id&#125;&lt;/select&gt; 但是如果起别名ResultMap就没啥意义了而且框架中一般都用第二种 2、我们此时就需要使用ResultMap结果集映射 其中要将结果集使用resultMap然后上面对其进行映射resultMap标签中 id为下面定义的resultMap名字让其完成映射 type为映射的类型 子标签id中 属性 column为数据库中字段名字 property为实体类中的字段名字","path":"2021/08/31/ResultMap结果集映射/","date":"08-31","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"生命周期和作用域","text":"生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。 先分析一下MyBatis执行过程 作用域理解 SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后， SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中， 而不要让其长期存在。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是 局部方法变量）。 SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。 由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多 个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导 致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。 因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以 说 SqlSessionFactory 的最佳作用域是应用作用域。 如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接 （Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这 条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所 以用 try…catch…finally… 语句来保证其正确关闭。 所以 SqlSession 的最佳的作用域是请求或方法作用域。","path":"2021/08/31/生命周期和作用域/","date":"08-31","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"Mybatis配置优化","text":"Propertise优化数据库的属性都是可以外部配置且可以动态替换的，既可以在Java属性文件中配置，也可以通过properties元素的子元素来传递 下面来优化一下配置文件 第一步、在资源目录下新建一个db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMTuser=rootpassword=zangzang 特别提示： 这里的url里边的&amp;符号因为我们之前使用的是xml文件配置的现在换成了properties所以要将&amp;amp；换成&amp;。 第二步、将文件导入properties配置文件 12345678910111213141516171819&lt;configuration&gt; &lt;!--只需要这一行就可导入--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/zang/dao/Mapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 还有一种方式就是直接在xml文件中使用properties里边的子标签配置 那么这个时候就有一个问题，如果我们两个地方同时配置了driver那么我们下边引用的时候他会引用哪个呢？？？ 其实他是这样的他先引用xml里边property里边的，然后去db.properties寻找，如果有的话会将前边property里边的覆盖掉 typeAliases优化typeAliases是在核心配置文件中起别名 分为类别名和包别名 1、类别名 列如这样我们可以给com.zang.dao.User取一个别名叫user，这样以后在用到这个类的时候就可以直接使用user 2、包别名 这样设置之后在com.zang.dao包底下所有的类别名都为类名的小写 映射器(mappers) 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们 需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所 以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完 全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心 的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配 置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL 语句，非常简洁。 1234&lt;!--使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;&lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt; 1234&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt; 1234&lt;!--使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt;&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt; 1234567&lt;!--将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt;&lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 我个人建议使用包扫描和相对路径资源引用","path":"2021/08/31/Mybatis配置优化/","date":"08-31","excerpt":"","tags":[{"name":"MyaBtis","slug":"MyaBtis","permalink":"https://zangblog.gitee.io/tags/MyaBtis/"}]},{"title":"VMware本地安装CentOS7","text":"开学了又多了一门新课程本来打算学完springboot在学可是既然学校有这门课程就提前学一下吧，我这个是模拟阿里云真实环境的适用于Java全栈，如果学运维的话还要更深入了解，废话不多说。 环境搭建1、虚拟机安装虚拟机的话我是在官网下载的，不过好多人推荐360傻瓜式安装，但是我个人比较不建议因为毕竟360全家桶懂的都得 官方网站下载 VMware Workstation Pro | CN 2、CentOS安装Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也 可以直接买一台学习用用！ 安装CentOs 可以使用别人制作好的镜像也可以在阿里云下载镜像（阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区 (aliyun.com)）然后选择自己需要的发行版和版本号，我这里使用的是CentOS 7.x版本所以我就把这个下载链接放这了下载链接 下载的话我不推荐使用浏览器下载真的太慢了，我这里推一个常用的下载器InternetDownloadManagerInternet Download Manager: the fastest download accelerator他可以同时开启多个线程进行下载 下载完之后打开VMware 选择新建直接下一步到这将镜像选择之后然后点最下边的 进行选择 最后改一下位置就行了 有不懂的联系QQ：2556450572","path":"2021/08/30/VMware本地安装CentOS7/","date":"08-30","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"https://zangblog.gitee.io/tags/Linux/"}]},{"title":"MyBatis Map和模糊查询扩展","text":"万能的Map 在接口方法中，参数直接传递Map 1int addUser2(Map&lt;String,Object&gt; map); 编写sql语句的时候需要传递参数类型参数类型为map 123&lt;insert id=&quot;addUser2&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user (id,name,pwd) values (#&#123;idd&#125;,#&#123;namee&#125;,#&#123;pwdd&#125;)&lt;/insert&gt; .在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求 123456789101112131415public void addUser2()&#123; SqlSession session = MyBatisUtil.getSession(); Mapper mapper = session.getMapper(Mapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;idd&quot;,4); map.put(&quot;namee&quot;,&quot;zzz&quot;); map.put(&quot;pwdd&quot;,&quot;11111&quot;); int i = mapper.addUser2(map); if(i&gt;0)&#123; System.out.println(&quot;数据插入成功&quot;); &#125; //增删改需要提交事务 session.commit(); session.close();&#125; 如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 模糊查询第1种：在Java代码中添加sql通配符。 12直接将mapper中的方法传递参数然后在java代码中将%条件%,传进去 第2种：在sql语句中拼接通配符，会引起sql注入 在xml中sql语句拼接%%，会引起sql注入不建议使用","path":"2021/08/29/MyBatis-Map和模糊查询扩展/","date":"08-29","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"MyBatis增删改查实现","text":"CRUD1、namespacenamespace中的包名要喝Dao/mapper接口的包名一致！ 2、select选择，查询语句 id：就是对应的namespace中的方法名 resultType：Sql语句执行的返回值 primaryType：参数类型 3、Insert4、update5、delete 编写接口 1234567891011package com.zang.dao;import java.util.List;public interface Mapper &#123; List&lt;User&gt; getUserList(); User getUserById(int id); int addUser(User user); int upDateUser(User user); int deleteUser(int id);&#125; 编写对应的mapper中的sql语句 1234567891011121314151617&lt;mapper namespace=&quot;com.zang.dao.Mapper&quot;&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.zang.dao.User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.zang.dao.User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.zang.dao.User&quot; &gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; &lt;update id=&quot;upDateUser&quot; parameterType=&quot;com.zang.dao.User&quot;&gt; update mybatis.user set pwd=#&#123;pwd&#125;,name=#&#123;name&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id=#&#123;id&#125; &lt;/delete&gt; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MapperTest &#123; @Test public void test()&#123; SqlSession session = MyBatisUtil.getSession(); Mapper mapper = session.getMapper(Mapper.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; session.close(); &#125; @Test public void testOne()&#123; SqlSession session = MyBatisUtil.getSession(); Mapper mapper = session.getMapper(Mapper.class); User userById = mapper.getUserById(2); System.out.println(userById); session.close(); &#125; @Test public void addUser()&#123; SqlSession session = MyBatisUtil.getSession(); Mapper mapper = session.getMapper(Mapper.class); int i = mapper.addUser(new User(4, &quot;zz&quot;, &quot;123456&quot;)); if(i&gt;0)&#123; System.out.println(&quot;数据插入成功&quot;); &#125; //增删改需要提交事务 session.commit(); session.close(); &#125; @Test public void upDateUser()&#123; SqlSession session = MyBatisUtil.getSession(); Mapper mapper = session.getMapper(Mapper.class); int i = mapper.upDateUser(new User(4, &quot;xx&quot;, &quot;123456&quot;)); if(i&gt;0)&#123; System.out.println(&quot;更新成功&quot;); &#125; session.commit(); session.close(); &#125; @Test public void deleteUser()&#123; SqlSession session = MyBatisUtil.getSession(); Mapper mapper = session.getMapper(Mapper.class); int i = mapper.deleteUser(4); if(i&gt;0)&#123; System.out.println(&quot;更新成功&quot;); &#125; session.commit(); session.close(); &#125;&#125;","path":"2021/08/29/MyBatis增删改查实现/","date":"08-29","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://zangblog.gitee.io/tags/Mybatis/"}]},{"title":"三大范式","text":"三大范式为什么需要数据规范化 信息重复 更新异常 插入异常 无法正常显示数据 删除异常 丢失有效的信息 1三大范式 第一范式原子性：保证每一列不可再分 第二范式前提：满足第一范式每张表只描述一件事情第三范式前提：满足第一和第二范式第三范式需要确保数据表中每一列数据和主键直接相关，而不能间接相关 规范和性能的问题关联查询表不能超过三张 * 考虑商业化的需求和目标，（成本，用户体验）数据库的性能更加重要 * 在规范性能的时候，需要适当的考虑一下规范性 * 故意给默写表增加一些冗余的阻断（从多表查询变为单表查询） * 故意增加一些计算列（从大数据量降低为小数据量的查询）","path":"2021/08/29/三大范式/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"MySQL备份","text":"为什么要备份： * 保证重要的数据不丢失 * 数据转移MySQL数据库备份的方式 * 直接拷贝物理文件 * 在Sqlyog这种可视化工具中手动导出 * 在想要导出的表或者库中，右键，选择备份或导出 * 使用命令行导出 mysqldump 命令行使用 1234567891011# mysqldump -hlocalhost -u用户名 -密码 -数据库 -表名mysqldump -hlocalhost -uroot -p123456 school student &gt;d:/a.sql-- 导出多张表mysqldump -hlocalhost -uroot -p123456 -school -student -xxxx -xxxx &gt;d:/a.sql-- 导入，登录的情况下，切换到指定的数据库source d:/a.sqlmysql -u用户名 -p密码 库名&lt;备份文件 假设你要备份数据库，防止数据丢失把数据库给朋友！sql文件给别人即可","path":"2021/08/29/MySQL备份/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"数据库权限管理","text":"基本命令 123456789101112131415161718192021222324252627282930313233343536/* 用户和权限管理 */ -----------------用户信息表：mysql.user-- 刷新权限 FLUSH PRIVILEGES -- 增加用户 CREATE USER kuangshen IDENTIFIED BY &#x27;123456&#x27; CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) -- 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 -- 只能创建用户，不能赋予权限。 -- 用户名，注意引号：如 &#x27;user_name&#x27;@&#x27;192.168.1.1&#x27; - --密码也需引号，纯数字密码也要加引号 -- 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的 混编值，需包含关键字PASSWORD-- 重命名用户 RENAME USER kuangshen TO kuangshen2 RENAME USER old_user TO new_user-- 设置密码 SET PASSWORD = PASSWORD(&#x27;密码&#x27;) -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD(&#x27;密码&#x27;) -- 为指定用户设置密码-- 删除用户 DROP USER kuangshen2 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;] - all privileges 表示所有权限 - - *.* 表示所有库的所有表 - - 库名.表名 表示某库下面的某表-- 查看权限 SHOW GRANTS FOR root@localhost; SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限","path":"2021/08/29/数据库权限管理/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"测试事务实现转账","text":"1234567891011-- 使用set语句来改变自动提交模式SET autocommit = 0; /*关闭*/ SET autocommit = 1; /*开启*/-- 注意: --- 1.MySQL中默认是自动提交 --- 2.使用事务时应先关闭自动提交-- 开始一个事务,标记事务的起始点 START TRANSACTION -- 提交一个事务给数据库 COMMIT-- 将事务回滚,数据回到本次事务的初始状态 ROLLBACK-- 还原MySQL数据库的自动提交 SET autocommit =1;-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 事务处理步骤 测试题目123456789101112131415/* 课堂测试题目A在线买一款价格为500元商品,网上银行转账. A的银行卡余额为2000,然后给商家B支付500. 商家B一开始的银行卡余额为10000创建数据库shop和创建表account并插入2条数据 */CREATE DATABASE `shop`CHARACTER SET utf8 COLLATE utf8_general_ci; USE `shop`; CREATE TABLE `account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(32) NOT NULL, `cash` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO account (`name`,`cash`) VALUES(&#x27;A&#x27;,2000.00),(&#x27;B&#x27;,10000.00)-- 转账实现 SET autocommit = 0; -- 关闭自动提交 START TRANSACTION; -- 开始一个事务,标记事务的起始点 UPDATE account SET cash=cash-500 WHERE `name`=&#x27;A&#x27;; UPDATE account SET cash=cash+500 WHERE `name`=&#x27;B&#x27;; COMMIT; -- 提交事务 # rollback; SET autocommit = 1; -- 恢复自动提交","path":"2021/08/29/测试事务实现转账/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"事务ACID","text":"原子性：要么都成功，要么都失败一致性：事务前后的数据完整性要保持一致隔离性：事务的隔离是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰事务之间要相互隔离持久性：事务一旦提交不可逆，会被持久化到数据库中 隔离所导致的一些问题脏读：指一个事务读取了另一个事务未提交的数据不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误的，只是某些场合不对）幻读是指在一个事务内读取到了别的事务插入的数据，导致前后不一致","path":"2021/08/29/事务ACID/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"数据库MD5加密","text":"MD5加密一、MD5简介MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛 使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉 字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 百度搜索md5介绍二、实现数据加密新建一个表 testmd5 123456CREATE TABLE `testmd5` ( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 插入一些数据 1INSERT INTO testmd5 VALUES(1,&#x27;zz&#x27;,&#x27;123456&#x27;),(2,&#x27;zangzang&#x27;,&#x27;456789&#x27; 如果我们要对pwd这一列数据进行加密，语法是： 1update testmd5 set pwd = md5(pwd); 如果单独对某个用户(如zz)的密码加密 1INSERT INTO testmd5 VALUES(3,&#x27;zangz&#x27;,&#x27;123456&#x27;) update testmd5 set pwd = md5(pwd) where name = &#x27;kuangshenzangzang&#x27;; 插入新的数据自动加密 1INSERT INTO testmd5 VALUES(4,&#x27;kuangshen3&#x27;,md5(&#x27;123456&#x27;)); 查询登录用户信息（md5对比使用，查看用户输入加密后的密码进行比对） 1SELECT * FROM testmd5 WHERE `name`=&#x27;kuangshen&#x27; AND pwd=MD5(&#x27;123456&#x27;);","path":"2021/08/29/数据库MD5加密/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"MySQL函数","text":"常用函数数据函数 12345SELECT ABS(-8); /*绝对值*/ SELECT CEILING(9.4); /*向上取整*/ SELECT FLOOR(9.4); /*向下取整*/ SELECT RAND(); /*随机数,返回一个0-1之间的随机数*/ SELECT SIGN(0); /*符号函数: 负数返回-1,正数返回1,0返回0*/ 字符串函数 123456789101112131415SELECT CHAR_LENGTH(&#x27;狂神说坚持就能成功&#x27;); /*返回字符串包含的字符数*/ SELECT CONCAT(&#x27;我&#x27;,&#x27;爱&#x27;,&#x27;程序&#x27;); /*合并字符串,参数可以有多个*/ SELECT INSERT(&#x27;我爱编程helloworld&#x27;,1,2,&#x27;超级热爱&#x27;); /*替换字符串,从某个位置开始替 换某个长度*/ SELECT LOWER(&#x27;KuangShen&#x27;); /*小写*/ SELECT UPPER(&#x27;KuangShen&#x27;); /*大写*/ SELECT LEFT(&#x27;hello,world&#x27;,5); /*从左边截取*/ SELECT RIGHT(&#x27;hello,world&#x27;,5); /*从右边截取*/ SELECT REPLACE(&#x27;狂神说坚持就能成功&#x27;,&#x27;坚持&#x27;,&#x27;努力&#x27;); /*替换字符串*/ SELECT SUBSTR(&#x27;狂神说坚持就能成功&#x27;,4,6); /*截取字符串,开始和长度*/ SELECT REVERSE(&#x27;狂神说坚持就能成功&#x27;); /*反转-- 查询姓周的同学,改成邹 SELECT REPLACE(studentname,&#x27;周&#x27;,&#x27;邹&#x27;) AS 新名字 FROM student WHERE studentname LIKE &#x27;周%&#x27;; 聚合函数 12345678910111213141516171819-- 聚合函数/*COUNT:非空的*/ SELECT COUNT(studentname) FROM student; SELECT COUNT(*) FROM student; SELECT COUNT(1) FROM student; /*推荐*/-- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。 -- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 -- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录； -- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。 /* 很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1) 可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的 条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不 同，它会统计该字段不为null的记录条数。下面它们之间的一些对比：1）在表没有主键时，count(1)比count(*)快 2）有主键时，主键作为计算条件，count(主键)效率高； 3）若表格只有一个字段，则count(*)效率较高。 */SELECT SUM(StudentResult) AS 总和 FROM result; SELECT AVG(StudentResult) AS 平均分 FROM result; SELECT MAX(StudentResult) AS 高分 FROM result;SELECT MIN(StudentResult) AS 低分 FROM result; 123456789101112-- 查询不同课程的平均分,高分,低分 -- 前提:根据不同的课程进行分组SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 高 分,MIN(StudentResult) AS 低分 FROM result AS r INNER JOIN `subject` AS s ON r.subjectno = s.subjectno GROUP BY r.subjectno HAVING 平均分&gt;80;/*where写在group by前面. 要是放在分组后面的筛选 要使用HAVING.. 因为having是从前面筛选的字段再筛选，而where是从数据表中的&gt;字段直接进行的筛选的 */","path":"2021/08/29/MySQL函数/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"套娃查询","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*============== 子查询 ================ 什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字; */-- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列-- 方法一:使用连接查询 SELECT studentno,r.subjectno,StudentResultFROM result r INNER JOIN `subject` subON r.`SubjectNo`=sub.`SubjectNo` WHERE subjectname = &#x27;数据库结构-1&#x27; ORDER BY studentresult DESC;-- 方法二:使用子查询(执行顺序:由里及外) SELECT studentno,subjectno,StudentResult FROM result WHERE subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;数据库结构-1&#x27; ) ORDER BY studentresult DESC;-- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名 -- 方法一:使用连接查询 SELECT s.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo` = r.`StudentNo` INNER JOIN `subject` sub ON sub.`SubjectNo` = r.`SubjectNo` WHERE subjectname = &#x27;高等数学-2&#x27; AND StudentResult&gt;=80-- 方法二:使用连接查询+子查询 -- 分数不小于80分的学生的学号和姓名 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo`WHERE StudentResult&gt;=80-- 在上面SQL基础上,添加需求:课程为 高等数学-2 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo` WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27;)-- 方法三:使用子查询 -- 分步写简单sql语句,然后将其嵌套起来 SELECT studentno,studentname FROM student WHERE studentno IN( SELECT studentno FROM result WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27; ) )","path":"2021/08/29/套娃查询/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"分页和排序","text":"1234567891011121314151617181920/*============== 排序 ================ 语法 : ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照ASC升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 */-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) -- 按成绩降序排序select s.`studentno`,`studentname`,`subjectname`,`studentresult`from `student` sinner join `result` ron s.`studentno`=r.`studentno`inner join `subject` subon sub.`subjectno`=r.`subjectno`where `subjectname`=&#x27;数据库结构-1&#x27;order by `studentresult` desc 123456789101112131415161718192021222324252627282930313233343536373839/*============== 分页 ================ 语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset 好处 : (用户体验,网络传输,查询压力)推导: 第一页 : limit 0,5 第二页 : limit 5,5 第三页 : limit 10,5 ...... 第N页 : limit (pageNo-1)*pageSzie,pageSzie [pageNo:页码,pageSize:单页面显示条数] */-- 每页显示5条数据 SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname=&#x27;数据库结构-1&#x27; ORDER BY StudentResult DESC , studentno LIMIT 0,5-- 查询 JAVA第一学年 -- 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数)SELECT s.`studentno`,`studentname`,`subjectname`,`studentresult`FROM `student` sINNER JOIN `result` rON s.`studentno`=r.`studentno`INNER JOIN `subject` subON r.`subjectno`=sub.`subjectno`WHERE `subjectname`=&#x27;JAVA第一学年&#x27;AND `studentresult`&gt;80ORDER BY `studentresult` DESCLIMIT 0,10","path":"2021/08/29/分页和排序/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"自连接及连表查询练习","text":"自连接数据表与自身进行连接需求:从一个包含栏目ID , 栏目名称和父栏目ID的表中 查询父栏目名称和其他子栏目名称 123456789101112131415161718192021222324252627282930313233343536373839-- 编写SQL语句,将栏目的父子关系呈现出来 (父栏目名称,子栏目名称) -- 核心思想:把一张表看成两张一模一样的表,然后将这两张表连接查询(自连接) SELECT a.categoryName AS &#x27;父栏目&#x27;,b.categoryName AS &#x27;子栏目&#x27; FROM category AS a,category AS b WHERE a.`categoryid`=b.`pid`-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno-- 查询学员及所属的年级(学号,学生姓名,年级名) SELECT studentno AS 学号,studentname AS 学生姓名,gradename AS 年级名称 FROM student s INNER JOIN grade g ON s.`GradeId` = g.`GradeID`-- 查询科目及所属的年级(科目名称,年级名称) SELECT subjectname AS 科目名称,gradename AS 年级名称 FROM SUBJECT sub INNER JOIN grade g ON sub.gradeid = g.gradeid-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname=&#x27;数据库结构-1&#x27;","path":"2021/08/29/自连接及连表查询练习/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"多表连接查询JOIN详解","text":"1JOIN对比 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-- 查询参加了考试的同学信息(学号,学生姓名,科目编号,分数)SELECT * FROM student;SELECT * FROM result;/*1.分析需求，确定查询的列来源于两个表，student result，连接查询2.确定使用哪种连接查询？（内连接）*/SELECT s.studentno,studentname,subjectno,studentresultFROM student sINNER JOIN result rON r.studentno=s.studentno-- 右连接(也可实现) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s RIGHT JOIN result r ON r.studentno = s.studentno-- 等值连接 SELECT s.studentno,studentname,subjectno,StudentResult FROM student s , result r WHERE r.studentno = s.studentno-- 左连接 (查询了所有同学,不考试的也会查出来) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s LEFT JOIN result r ON r.studentno = s.studentno-- 查一下缺考的同学(左连接应用场景)SELECT s.studentno,studentname,subjectno,StudentResult FROM student sLEFT JOIN result rON r.`studentno`=s.`studentno`WHERE `studentresult` IS NULL-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) /*思路1.需求分析，分析查询的字段来自哪些表，student、result、subject（连接查询）2.确定使用哪种类型连接查询？7种确定交叉点（这两个表中哪些数据是相同的）判断的条件：学生表中的studentNo=成绩表 studentNo*/SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` subON sub.subjectno = r.subjectno","path":"2021/08/29/多表连接查询JOIN详解/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"使用SQL查询数据","text":"DQL语言DQL( Data Query Language 数据查询语言 ) 查询数据库数据 , 如SELECT语句 简单的单表查询或多表的复杂查询和嵌套查询 是数据库语言中核心,重要的语句 使用频率高的语句 1SELECT语法 123456789SELECT [ALL | DISTINCT] &#123;* | table.* | [table.field1[as alias1][,table.field2[as alias2]] [,...]]&#125; FROM table_name [as table_alias] [left | right | inner join table_name2] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;]; -- 指定查询的记录从哪条至哪条 注意 : [ ] 括号代表可选的 , { }括号代表必选得 指定查询字段123查询表中所有的数据列结果 , 采用 **&quot; \\* &quot;** 符号; 但是效率低，不推荐 .-- 查询所有学生信息 SELECT * FROM student;-- 查询指定列(学号 , 姓名) SELECT studentno,studentname FROM student; 1AS作为语句别名 可给数据列取一个新别名可给表取一个新别名可把经计算或总结的结果用另一个新名称来代替 12345678910--这里是为列取别名(当然as关键词可以省略)SELECT studentno AS 学号,studentname AS 姓名 FORM student;-- 使用as也可以为表取别名SELSCT studenton AS 学号，studentname AS 姓名 FROM AS s-- 使用as，为查询结果取一个新名字--CONCAT()函数拼接一个字符串SELECT CONCAT(&#x27;姓名：&#x27;studentname) AS 新姓名 FROM student; 1DISTINCT关键字的使用 作用：去掉SELECT查询返回的记录结果中重复的记录（返回所以列的值都一样），只返回一条 1234567-- 查询一下有哪些同学参加了考试，成绩SELECT * FORM result --查询全部的考试成绩SELECT `studentNo` FROM result -- 查询有哪些同学参加了考试SELECT DISTING `StudentNo` FROM result-- 发现重复数据，去重-- ===============where=======================SELECT studentNo,`StudentResult` FROM result 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566-- 查询考试成绩在95-100之间的SELECT `studentno`,`studentresult` FROM resultWHERE `studentresult`&gt;=95 AND `studentresult`&lt;=100-- and &amp;&amp;SELECT `studentno`,`studentresult` FROM `result`WHERE `studentresult`&gt;=95 &amp;&amp; `studentresult`&lt;=100-- 模糊查询SELECT `studentno`,`studentresult` FROM `result`WHERE `studentresult` BETWEEN 95 AND 100-- 除了1000号学生之外的同学成绩SELECT `studentno`,`studentresult` FROM `result`WHERE `studentno`!=1000-- != NOT-- 模糊查询 between and \\ like \\ in \\ null-- ========================================-- Like-- ========================================-- 查询姓刘的同学的学号及姓名-- Like结合使用的通配符：%(代表0到任意个字符) _(一个字符)SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;刘%&#x27;;-- 查询姓刘的同学,后面只有一个字的SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;刘_&#x27;;-- 查询姓刘的同学,后面只有两个字的SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;刘__&#x27;;-- 查询姓名中含有 嘉 字的SELECT `studentno`,`studentname` FROM `student`WHERE `studentname` LIKE &#x27;%嘉%&#x27;-- 查询姓名中含有特殊字符的需要使用转义符号 &#x27;\\&#x27; -- 自定义转义符关键字: ESCAPE &#x27;:&#x27;-- ============================================= -- IN -- ============================================= -- 查询学号为1000,1001,1002的学生姓名 SELECT `studentno`,`studentname` FROM `student`WHERE `studentno` IN (1000,1001,1002)-- 查询地址在北京,南京,河南洛阳的学生 SELECT studentno,studentname,address FROM student WHERE address IN (&#x27;北京&#x27;,&#x27;南京&#x27;,&#x27;河南洛阳&#x27;);-- ============================================= -- NULL 空 -- ============================================= -- 查询出生日期没有填写的同学 -- 不能直接写=NULL , 这是代表错误的 , 用 is null SELECT `studentname` FROM `student`WHERE `borndate` IS NULL -- 查询出生日期填写的同学 SELECT studentname FROM student WHERE BornDate IS NOT NULL;-- 查询没有写家庭住址的同学(空字符串不等于null) SELECT studentname FROM student WHERE Address=&#x27;&#x27; OR Address IS NULL","path":"2021/08/29/使用DQL查询数据/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"MySQL数据管理","text":"DML语言数据库意义：数据储存、数据管理管理数据库数据方法： * 通过SQLLyog等管理工具管理数据库数据 * 通过DML语句管理数据库数据==DML语言==:数据操作语言 * 用于操作数据库对象中所包含的数据 * 包括： INSERT（添加数据语句） UPDATE(更新数据语句） DELETE（删除数据语句） 添加数据1INSERT语句 语法： 1INSERT INTO 表名 (字段一，字段二...) VALUES (&#x27;值1&#x27;,&#x27;值2&#x27;, ...) 注意 字段或值之间用英语逗号隔开 字段一,字段二…’这部分可以省略，但添加的值务必与表结构，数据列，顺序相对应，且输了一致 可同时插入多条数据，balyes后用英文逗号隔开 12345678910111213-- 使用语法如何增加语句-- 语法：INSERT INTO 表名 [(字段1,字段2,...)] values (&#x27;值1&#x27;,&#x27;值2&#x27;..)INSERT INTO student (NAME) VALUES (&#x27;臧臧&#x27;);-- 主键自增，那能否省略呢INSERT INTO student VALUE (&#x27;木马臧臧&#x27;);-- 查询:INSERT INTO grade VALUE (&#x27;大二&#x27;)错误代码： 1136 Column count doesn`t match value count at row 1-- 结论:&#x27;字段1,字段2...&#x27;该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一 致-- 结论:&#x27;字段1,字段2...&#x27;该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一 致.-- 一次插入多条数据 INSERT INTO grade(gradename) VALUES (&#x27;大三&#x27;),(&#x27;大四&#x27;); 修改数据1update 命令 语法 1UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHERE condition] 注意 : column_name 为要更改的数据列 value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果 condition 为筛选条件 , 如不指定则修改该表的所有列数据 1where条件语句 测试 12-- 修改年级信息UPDATE grade SET gradename = &#x27;高中&#x27; WHERE gradeid = 1 删除1delete命令 语法 1DELETE FROM 表名 [WHERE condition] 注意：condition为筛选条件 , 如不指定则删除该表的所有列数据 1-- 删除后一个数据 DELETE FROM grade WHERE gradeid = 5 作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ;语法：TRUNCATE [TABLE] table_name; -- 清空年级表 TRUNCATE grade注意：区别于DELETE命令相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快不同 : * 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器 * 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说测试 12345678910111213141516-- 创建一个测试表 CREATE TABLE `test` ( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8-- 插入几个测试数据 INSERT INTO test(coll) VALUES(&#x27;row1&#x27;),(&#x27;row2&#x27;),(&#x27;row3&#x27;);-- 删除表数据(不带where条件的delete) DELETE FROM test;-- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志. -- 删除表数据(truncate) TRUNCATE TABLE test; -- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志.-- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后 -- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失) -- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失)","path":"2021/08/29/MySQL数据管理/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"修改和删除数据表结构","text":"修改删除表1修改表 修改表名：ALTER TABLE 旧表明 RENAME AS 新表名添加字段：ALTER TABLE 表名 ADD 字段名 列属性修改字段： ALTER TABLE 表名 MODIFY 字段名列类型 修改约束 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 字段重命名1删除 ALTER TABLE 表名 DROP 字段名删除数据表： 语法 ： DROP TABLE [IF EXISTS] 表名 IF EXISTS 为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 12345678910111. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文 也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、 换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\&#x27; 5.CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结 束。delimiter 可修改当前对话的语句结束符。6. SQL对大小写不敏感 （关键字）","path":"2021/08/29/修改和删除数据表结构/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"MyISAM和InnoDB的区别","text":"数据表的类型12345--关于数据库引擎/*INNODB 默认使用MYISAM 早些年使用的*/ 经验 ( 适用场合 ) : 适用 MyISAM : 节约空间及相应速度 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表 1数据表的存储位 ·MySQL数据表以文件方式存放在磁盘中 包括表文件 , 数据文件 , 以及数据库的选项文件 位置 : Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 .· 注意 : InnoDB类型数据表只有一个 *.frm文件 , 以及上一级目录的ibdata1文件 MyISAM类型数据表对应三个文件 : . frm – 表结构定义文件 . MYD – 数据文件 ( data ) . MYI – 索引文件 ( index ) 1设置数据表字符集 我们可为数据库,数据表,数据列设定不同的字符集，设定方法 : 创建时通过命令来设置 , 如 : CREATE TABLE 表名()CHARSET = utf8; * 如无设定 , 则根据MySQL数据库配置文件 my.ini 中的参数设定","path":"2021/08/29/MyISAM和InnoDB的区别/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"创建数据库表","text":"– AUTO_INCREMENT日增字符串使用单引号括起来! 1234567891011121314--所有的语句后面加，(英文的) ，最后一个不用加-- PRIMARY KEY主键，一 般-一个表只有一一个唯一 -的主键!CREATE TABLE IF NOT EXISTS ·student·(·id· INT(4) NOT NULL AUTO_ INCREMENT COMMENT &#x27; 学号&#x27;,·name· VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27; ,·pwd· VARCHAR(20)NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27; 密码&#x27;,·sex· VARCHAR(2) NOT NULL DEFAULT &#x27;女’COMMENT &#x27;性 别&#x27;,·birthday· DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,·address· VARCHAR (100) DEFAULT NULL COMMENT &#x27; 家庭住址&#x27;,emai1’VARCHAR(50) DEFAULT NULL COMMENT &#x27; 邮箱&#x27;,PRIMARY KEY( id )) ENGINE= INNODB DEFAULT CHARSET=utf8 123456CREATE TABLE [IF NOT EXISTS]‘表名” (·字段名· 列类型[属性] [索引] [注释]，·宁收名· 列类型[属性] [索引] [冲释]，·字段名· 列类型[属性] [索引] [注释])[表类型] [字符集设置][注释]","path":"2021/08/29/创建数据库表/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"数据库的字段属性","text":"==Unsigned==： * 无符号的整数 * 声明的该列不能声明为负数==zerofill==： * 0填充的 * 不足的位数，使用0来填充，int（3），5…005==自增==： * 通常理解为自增，自动在上一条记录的基础上+1（默认） * 通常用来设置唯一的主键 -index，必须是整数类型 * 可以自定义设计主键自增的起始值和步长==非空==： * 假设设置为not null ，如果不给他赋值，就会报错！ * NULL，如果不填写值，默认就是null ==默认==： * 设置默认值 * sex，默认值为难，如果不值当该列的值，则会有默认的值！","path":"2021/08/29/数据库的字段属性/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"列的数据类型","text":"数据库的列类型1数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小的数据 3个字节 int 标准的整数 4个字节 bigint 较大的数据 8个字节 float 浮点数 4个字节 double 浮点数 8个字节 （精度问题） decimal 字符串形式的浮点数 金融计算的时候，一般是decimal 1字符串 char 字符串 0-255 varchar 可变字符串 0-65535 常用的 tinytext 微型文本 2^8-1 text 文本串 2^16-1 保存大文本 1时间和日期 java.util.Data date YYYY-MM-DD日期 time HH：mm：ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳，1970.1.1到现在的毫秒数 1null 没有值，未知 ==注意，不要使用NULL运行运算，结果为NULL","path":"2021/08/29/列的数据类型/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"操作数据库语句","text":"操作数据库&gt;操作数据库中的表&gt;操作数据库中表的数据==mysql的关键字不区分大小写== 操作数据库 创建数据库 12CREATE DATABASE [IF NOT EXISTS] school 删除数据库 1DROP DATABASE [IF EXISTS] cccc 使用数据库 12-- tab 键的上面，如果你的表名或者字段名是一个特殊字符，就需要带``SELECT `user` FROM student 查看数据库 1show databases--查看所有数据库 学习思路 对照sqlyog可视化历史记录查看sql 固定的语法或关键字必须要记住","path":"2021/08/29/操作数据库语句/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"基本的命令行操作","text":"1234567891011121314151617181920mysql -uroot -p123456 --连接数据库update mysql user set authentication_staring=password（&#x27;123456&#x27;） where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;; --修改密码flush privileges; --刷新版权-------------------------------------------所有的语句使用;结尾show databases; --查看所有的数据库mysql&gt; use school --切换数据库 use 数据库名Database changedshow tables;--查看数据库中所有的表describe student; --显示数据库中所有表的信息create database westos; --创建一个数据库exit;--退出连接--单行注释","path":"2021/08/29/基本的命令行操作/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"安装MySQL详细说明(以及各种报错问题的解决)","text":"安装MySQL 解压 把这个包放到自己的电脑环境目录下 配置环境变量 新建mysql配置文件ini 注意目录一定要换成自己的123456[mysqld] basedir=E:\\IntelliJ IDEA 2020.1.1\\mysql-5.7.19\\datadir=D:\\Program Files\\mysql-5.7\\data\\ port=3306 skip-grant-tables 启动管理员模式下的CMD，运行所有的命令 安装mysql服务 初始化数据库文件 启动mysql，进去修改密码（下面是我自己遇到的坑纯手写希望大家可以避坑，作为小白肯定会有帮助在启动这个地方我吃了好多坑下面说一下可能遇到的问题 mysqld –initialize-insecure –user=mysql当输入这个初始化数据文件的时候如果报错极大可能就是imi配置路径不对 还有一点就是在次启动mysql时报错 发生系统错误 2 系统找不到指定的文件。这个时候切换到bin目录后，先删除前面安装的mysql服务（删除服务不一定要到bin目录），再重新在bin目录下安装mysql服务。那么问题来了.再删除的时候会报这样的错误[SC] DeleteService 失败 1072: 指定的服务已标记为删除。这个时候要关闭服务管理界面然后重新以管理员的方式打开cmd重新删除，删除成功重新输入mysqld -install然后就可以启动了） 进入mysql通过命令行（-p后边不要加空格），修改密码（sql语句最后一定要加分号！） 注掉ini中的跳过密码 重启mysql，连接测试，如果连接成功就ok","path":"2021/08/29/安装MySQL详细说明-以及各种报错问题的解决/","date":"08-29","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"第一次使用mybatis，以及各种采坑解决办法","text":"1、首先要搭建一个环境 创建数据库啥的就不写了自己创建一个自己用于测试用的数据库 创建maven项目，推荐使用maven父子项目 导入maven依赖 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--mysql驱动--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--这个是一个坑，用于导出静态资源的--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 2、编写Myabtis核心配置文件123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=GMT&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;zangzang&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--这个呢是每次写一个mapper接口的对应mapper都要在这里边注册一下--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/zang/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3、编写MyBatis工具类这一部分可以根据mybatis官方文档来看 12345678910111213141516public class MyBatisUtil &#123; private static SqlSessionFactory build; static &#123; try &#123; String resource=&quot;mybatis-config.xml&quot;; InputStream resourceAsStream = Resources.getResourceAsStream(resource); build = new SqlSessionFactoryBuilder().build(resourceAsStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSession()&#123; return build.openSession(); &#125;&#125; 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。 4、创建实体类12345678public class User &#123;private int id; //idprivate String name; //姓名private String pwd; //密码//构造,有参,无参//set/get//toString()&#125; 5、编写Mapper接口类123public interface UserMapper &#123;List&lt;User&gt; selectUser();&#125; 6、编写Mapper.xml配置文件这个xml其实就相当于我们当初的接口实现类，对应接口就是重写方法其实 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--这个用来对应接口--&gt;&lt;mapper namespace=&quot;com.zang.dao.UserDao&quot;&gt;&lt;!--这个用来对接口里边的方法，以及所返回的类型--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.zang.dao.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 7、编写测试类1234567891011121314public class UserDaoTest &#123; @Test public void test()&#123; //获取SqlSession对象 SqlSession session = MyBatisUtil.getSession(); //这里使用了动态代理将获得userdao的class对象 UserDao mapper = session.getMapper(UserDao.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; session.close(); &#125;&#125; 下面说一下遇到的坑1、xml不能有中文注释2、useSSL=false3、MybatisUtils.java里面，原来是SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 改成——sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 去了最前面的声明，因为前面 已经声明过了，private static SqlSessionFactory sqlSessionFactory;//提升作用域！！！","path":"2021/08/28/第一次使用mybatis，以及各种采坑解决办法/","date":"08-28","excerpt":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"}]},{"title":"SMBMS用户管理底层实现","text":"我们写到现在面临一个问题如果我们去跳转密码修改和退出登录时他都会去跳转一个页面，但是我们在进行用户管理和各种管理的时候跳转的都是servlet请求 先分析一下页面做了些什么 首先我们看他有一个头部就是输入用户名和选择用户角色的第二部分就是用户信息，尾部呢就是显示记录啥的，显示用户名和角色名这就需要连表查询，而且下面尾部还有分页，然后又查询总的信息量 用户管理实现 写分页的工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class PageSupport &#123; //当前页码-来自于用户输入 private int currentPageNo = 1; //总数量（表） private int totalCount = 0; //页面容量 private int pageSize = 0; //总页数-totalCount/pageSize（+1） private int totalPageCount = 1; public int getCurrentPageNo() &#123; return currentPageNo; &#125; public void setCurrentPageNo(int currentPageNo) &#123; if(currentPageNo &gt; 0)&#123; this.currentPageNo = currentPageNo; &#125; &#125; public int getTotalCount() &#123; return totalCount; &#125; //学习面向对象的时候学了封装，继承，多态，其实封装里边的set方法还可以限定一些不安全的情况如果写在别的地方会很繁琐 public void setTotalCount(int totalCount) &#123; if(totalCount &gt; 0)&#123; this.totalCount = totalCount; //设置总页数 this.setTotalPageCountByRs(); &#125; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; if(pageSize &gt; 0)&#123; this.pageSize = pageSize; &#125; &#125; public int getTotalPageCount() &#123; return totalPageCount; &#125; public void setTotalPageCount(int totalPageCount) &#123; this.totalPageCount = totalPageCount; &#125; public void setTotalPageCountByRs()&#123; if(this.totalCount % this.pageSize == 0)&#123; this.totalPageCount = this.totalCount / this.pageSize; &#125;else if(this.totalCount % this.pageSize &gt; 0)&#123; this.totalPageCount = this.totalCount / this.pageSize + 1; &#125;else&#123; this.totalPageCount = 0; &#125; &#125; &#125; ​ 用户列表页面导入 1、获取用户数量 UserDao UserDaoImpl 这个实现起来别的其实都一样，只是要根据不同情况变sql UserService UserServiceImpl 2、获取用户列表 .. ```javapublic List getUserList(Connection connection, String userName, int userRole, int currentPageNo, int pageSize) throws Exception &#123; // TODO Auto-generated method stub PreparedStatement pstm = null; ResultSet rs = null; List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); if(connection != null)&#123; StringBuffer sql = new StringBuffer(); sql.append(&quot;select u.*,r.roleName as userRoleName from smbms_user u,smbms_role r where u.userRole = r.id&quot;); List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); if(!StringUtils.isNullOrEmpty(userName))&#123; sql.append(&quot; and u.userName like ?&quot;); list.add(&quot;%&quot;+userName+&quot;%&quot;); &#125; if(userRole &gt; 0)&#123; sql.append(&quot; and u.userRole = ?&quot;); list.add(userRole); &#125; sql.append(&quot; order by creationDate DESC limit ?,?&quot;); currentPageNo = (currentPageNo-1)*pageSize; list.add(currentPageNo); list.add(pageSize); Object[] params = list.toArray(); System.out.println(&quot;sql ----&gt; &quot; + sql.toString()); rs = BaseDao.resultSet(connection,sql.toString(),pstm,params,rs); while(rs.next())&#123; User _user = new User(); _user.setId(rs.getInt(&quot;id&quot;)); _user.setUserCode(rs.getString(&quot;userCode&quot;)); _user.setUserName(rs.getString(&quot;userName&quot;)); _user.setGender(rs.getInt(&quot;gender&quot;)); _user.setBirthday(rs.getDate(&quot;birthday&quot;)); _user.setPhone(rs.getString(&quot;phone&quot;)); _user.setUserRole(rs.getInt(&quot;userRole&quot;)); _user.setUserRoleName(rs.getString(&quot;userRoleName&quot;)); userList.add(_user); &#125; BaseDao.closeResource(null, pstm, rs); &#125; return userList; } 12345678910111213141516171819202122233. ..4. ```java public List&lt;User&gt; getUserList(String queryUserName, int queryUserRole, int currentPageNo, int pageSize) &#123; // TODO Auto-generated method stub Connection connection = null; List&lt;User&gt; userList = null; System.out.println(&quot;queryUserName ---- &gt; &quot; + queryUserName); System.out.println(&quot;queryUserRole ---- &gt; &quot; + queryUserRole); System.out.println(&quot;currentPageNo ---- &gt; &quot; + currentPageNo); System.out.println(&quot;pageSize ---- &gt; &quot; + pageSize); try &#123; connection = BaseDao.getconnection(); userList = userDao.getUserList(connection, queryUserName,queryUserRole,currentPageNo,pageSize); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; BaseDao.closeResource(connection, null, null); &#125; return userList; &#125; 3、获取角色操作 RoleDao RoleDaoImpl RoleService RoleServiceImpl","path":"2021/08/23/SMBMS用户管理底层实现/","date":"08-23","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"SMBMS密码修改功能实现","text":"修改密码的实现大致上是和登录一样的1.1、首先写dao层1public boolean upPwd(Connection connection,int id,String password); 1.2、然后写对应的实现类12345678910111213141516public boolean upPwd(Connection connection, int id, String password) &#123; Object[] primarys=&#123;password,id&#125;; PreparedStatement preparedStatement=null; String sql = &quot;update smbms_user set userPassword=? where id=?&quot;; boolean flag = false; if(connection!=null)&#123; try &#123; BaseDao.execute(connection,sql,preparedStatement,primarys); flag=true; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; return flag;&#125; 2.1、service层1public boolean upPwd(int id,String password); 2.2、对应实现类123456789public boolean upPwd(int id, String password) &#123; boolean flag=false; Connection connection = BaseDao.getconnection(); UserDao userDao = new UserDaoimpl(); if(userDao.upPwd(connection,id,password))&#123; flag=true; &#125; return true;&#125; 3、servlet1234567891011121314151617181920212223protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;servlet&quot;); User uuu = (User) req.getSession().getAttribute(&quot;uuu&quot;); int id = uuu.getId(); String newpassword = (String) req.getAttribute(&quot;newpassword&quot;); if(uuu!=null&amp;&amp;newpassword!=null)&#123; UserService userService = new UserServiceimpl(); if(userService.upPwd(id,newpassword))&#123; req.getSession().removeAttribute(&quot;uuu&quot;); req.setAttribute(&quot;message&quot;,&quot;密码修改成功&quot;); &#125;else &#123; req.setAttribute(&quot;message&quot;,&quot;密码修改失败&quot;); &#125; &#125;else &#123; req.setAttribute(&quot;message&quot;,&quot;账号不正确&quot;); &#125; req.getRequestDispatcher(&quot;/error.jsp&quot;);&#125;@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp);&#125;","path":"2021/08/18/SMBMS密码修改功能实现/","date":"08-18","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"SMBMS注销及权限过滤","text":"注销功能实现这个功能的原理呢实际上是将我们之前存在session里的用户删除然后重定向到登录页就可以了 每次写完servlet千万别忘记配置xml文件哦 123456789&lt;!--注销功能实现--&gt;&lt;servlet&gt; &lt;servlet-name&gt;loginout&lt;/servlet-name&gt; &lt;servlet-class&gt;com.zang.servlet.LogOutServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;loginout&lt;/servlet-name&gt; &lt;url-pattern&gt;/jsp/logout.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 过滤功能过滤就是将session取出来判断存不存在 123456789&lt;!--过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;loginout&lt;/filter-name&gt; &lt;filter-class&gt;com.zang.filter.LogoutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;loginout&lt;/filter-name&gt; &lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;","path":"2021/08/18/SMBMS注销及权限过滤/","date":"08-18","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"SMBMS登录流程","text":"首先啊我们这个架构肯定是dao层去和数据库打交道，然后service去调用dao层最后servlet层对其进行转发处理1、Dao层1.1、我们要做的就是将你前台输入的用户从数据库查出来 我们将userCode和userPassword作为条件从中得到这个人 面向接口化编程 1.2、创建一个UserDao接口里边很简单写一个方法就行 1.3、然后去写实现这个接口的类UserDaoimpl 2、service层2.1、接口 2.2、实现类 3、servlet层3.1、继承httpservlet然后重写dopost和doget方法 最后不能忘记配置web.xml","path":"2021/08/17/SMBMS登录流程/","date":"08-17","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"SMBMS基础环境搭建","text":"Tomcat就不说了还有实体类自己去对应数据库写1、首先我们要创建一个maven项目然后将所需要的依赖导入12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、然后我们首先要进行数据库连接所有需要所对应数据库的driver和url，然后username和password为了方便管理我们将他们放到db.properties文件里边然后使用反射去取我的数据 3、下面一步就是我们要将连接数据库和对数据库的操作都封装在dao包的BaseDao里边，这个dao包可以理解为专门去和数据库打交道的一层我就直接将步骤解释写代码里了3.1对其中几个连接数据库的参数进行赋值 3.2、创建获得Connection的方法 3.3、对数据进行查询的方法 3.4、对数据进行修改的方法 3.5关闭closeResource 4、写完BaseDao之后我们为了防止乱码还要写一个过滤器这就没什么好说的了直接去除乱码三件套关于过滤器不懂的可以在博客搜索我里边有写 写完之后千万不能忘记在web.xml里边配置，基本的怎么配置啥的自己去看基础 5、写完过滤器还要给网站添加一个欢迎页一打开就是他也就是登陆页面 好了，这就是基本的环境搭建","path":"2021/08/17/SMBMS基础环境搭建/","date":"08-17","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"索引的失效","text":"索引的失效失效的第一种情况1select * from emp where ename like &#x27;%T&#x27; ​ 此时即使ename上即使添加了索引，也不会走索引，因为当前使用的是模糊查询，其中以%开头了。应该尽量避免模糊查询的时候以%开头—–这是一种优化的手段 失效的第二种情况​ 使用or的时候可能会失效，如果使用or那么要求or的两边的条件字段都要有索引，此时才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会失效，所以这就是为什么不建议使用or的原因。 失效的第三种情况​ 使用复合索引的时候，没有使用左侧的列查找，索引失效 ​ 复合索引就是当两个字段或者更多的字段联合起来添加一个索引，叫做复合索引。 ​ 比如 12345create index emp_job_sal_index on emp(job,sal)-- 当执行这种查询语句的时候索引有效select * from emp where job=&#x27;MANAGER&#x27;-- 此时有效-----------------------------------------------select * from emp where sal=100 -- 此时无效 失效的第四种情况​ 在where当中索引列参加了运算，索引也会失效 123select * from emp where sal=100 -- 此时索引不会失效-------------------------------------------------select * from emp shere sal+1=100 -- 此时索引会失效 失效的第五种情况​ 早where当中索引列使用了函数索引也会失效","path":"2021/08/13/索引的失效/","date":"08-13","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"索引的原理","text":"索引的实现原理 id name 每一行记录在硬盘上的物理存储编号 100 张三 0x123 120 李四 0x456 99 王五 0x897 88 赵六 0x565 101 臧臧 0x465 55 嘻嘻 0x222 130 zzz 0x666 在任何数据库当中主键都会自动添加索引对象，id字段上字段有索引，因为id是主键，另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象 在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号 在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，存储索引在一个.MYI文件中在InnoDB存储引擎中索引存储在一个逻辑名称为tablespace的当中，在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式(B树) 12345-- 如果有这样一条查找语句select * from user where `id`=101-- 当mysql发现id字段上有索引对象，会痛的索引对象idindex进行查找快速定位-- 通过101得出物理编号0x222，此时sql语句转换select * from user where 物理编号=0x222 -- 此时就可以直接定位 什么条件下，我们会考虑给字段添加索引呢? 条件 数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同) 该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。 该字段很少的DML(insert delete update)操作。(因为DM之后，索引需要重新排序。 建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。建议通过主键查询，通过unique约束的字段进行查询，效率是比较高的。","path":"2021/08/13/索引的原理/","date":"08-13","excerpt":"","tags":[{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"}]},{"title":"Filter过滤器","text":"Filter过滤器这个东西啊很好理解 他可以简化很多操作，比如我们有好多页面而且我们每个页面都要去乱码我们每个servlet都要去写去除乱码三件套 123request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); 而这样会使程序耦合性很高 所以这时候我们就需要过滤器去帮我们做一些事情 Filter开发步骤 导包 编写过滤器 不要导错包，要导入servlet下的 实现接口重写对应方法就可 1234567891011121314151617181920212223242526public class FilterDemo implements Filter &#123; @Override //初始化:web服务器启动就已经初始化了，随后等待过滤对象出现 public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); //chain 链 /* * 1.过滤中的所有代码，在过滤特定请求的时候都会执行 * 2.必须要让过滤器继续执行 * */ chain.doFilter(request,response);//让我们的请求走，如果不写这段程序到这就会被拦截 &#125; @Override //销毁：web服务器关闭的时候，过滤会销毁 public void destroy() &#123; &#125;&#125; 到这还没结束，我们现在还差一步就是我们这个过滤去要去过滤哪些网站就是哪些网站需要我们这个过滤器去过滤，所以最后我们要在web.xml里边配置Filter 12345678910&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.kuang.filter.CharacterEncodingFilter&lt;/filter\u0002class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt; &lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;&lt;/filter-mapping&gt;","path":"2021/08/09/Filter过滤器/","date":"08-09","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"JSP原理剖析","text":"什么是JSPjsp是Java servlet pages的简称所谓jsp就是java服务器端页面，也和servlet一样，用于动态web技术! 最大的特点就是： - 写JSP就像在写HTML 区别：- HTML只能给用户提供静态的数据 - JSP页面中可以嵌入Java代码，为用户提供动态数据； JSP原理思路：JSP到底是怎么执行的! 代码层面没有任何问题 服务器内部工作 ​ tomcat中有一个work目录； ​ IDEA中使用Tomcat会在Idea的tomcat中产生一个work目录 在我电脑中的地址为： E:\\环境\\apache-tomcat-9.0.48\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp 发现页面变成了java文件 其实浏览器向服务器发送请求不管访问什么资源，其实都是在访问Servlet jsp最终也会被转换成一个java类! jsp本质就是一个servlet ​ 我们去看jsp源码会发现 ​ 他会和servlet十分类似 12345678910//初始化public void _jspInit() &#123;&#125;//销毁public void _jspDestroy() &#123;&#125;//JSPServicepublic void _jspService(.HttpServletRequest request,HttpServletResponseresponse) 判断请求方式 帮助我们内置一些对象，方便直接使用 12345678final javax.servlet.jsp.PageContext pageContext; //页面上下文javax.servlet.http.HttpSession session = null; //sessionfinal javax.servlet.ServletContext application; //applicationContextfinal javax.servlet.ServletConfig config; //configjavax.servlet.jsp.JspWriter out = null; //outfinal java.lang.Object page = this; //page：当前HttpServletRequest request //请求HttpServletResponse response //响应 输出页面前增加的代码 123456789response.setContentType(&quot;text/html&quot;); //设置响应的页面类型pageContext = _jspxFactory.getPageContext(this, request, response,null, true, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();session = pageContext.getSession();out = pageContext.getOut();_jspx_out = out; 以上这些对象我们都可以直接在jsp页面中直接使用! 其实吧我个人理解，在JSP的底层，其实就是相当于帮我们进行了一下封装，然后到时候我们就可以直接使用 只要是Java代码就会原封不动的输出 如果是HTML代码就会被转换成 out.write(“\\r\\n”); 这样然后输出到前端去","path":"2021/08/08/JSP原理剖析/","date":"08-08","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"Cookie和Session详解","text":"Cookie会话会话：假如我打开了一个浏览器点击了很多链接，访问了多个web资源，然后我不想看的时候关闭了浏览器，这个过程就叫做会话。 有状态会话：这个有状态会话简单来说就是，你在班里很出色，然后你来了班里大家对你印象很深都知道你来过了，你下次再来的时候大家都知道你曾经来过，这个称之为有状态会话 假如你被学校录取了你怎么才能证明你被录取了？ 有两种方式 ​ 录取通知书 ​ 学校官网存档 那么cookie就是第一种方式，就是假如我被沧州师范录取了，学校不给发通知书，只能自己去学校拿然后去学校拿通知书的时候就相当于我是客户端学校是服务端。我第一次访问的时候学校给了我一个cookie，其中有两个参数(key为我的名字)(value为沧州师范),然后等我下次去的时候我带着cookie去就可以了 session就是第二种我去了学校把我的信息全部录进了电脑里然后下次我去的时候让服务端去匹配我。 保存会话的两种技术 cookie 客户端技术(响应，请求) session 服务器技术，利用这个技术，可以保存用户的会话信息 我们可以把信息或者数据放在Session 中！ 常见现象：网站登录之后，你下次再访问就不用登录了，第二次访问就直接自动登陆上去了 cookie 123456Cookie[] cookies = req.getCookies();//客户端获得cookiecookie.getName();//获得cookie中的keycookie.getValue();//获得cookie中的valueCookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);//新建一个cookieresq.addCookie(cookie);//响应给客户端一个cookiecookie.setMaxAge(24*60*60);//设置cookie有效期 细节问题 一个网站cookie是否存在上限 一个cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie； cookie大小有限制4kb； 300个cookie浏览器上限 删除cookie 不设置有效期，关闭浏览器自动失效 设置有效期为0.(这种方法效率高) 编码与解码 URLEncoder.encode(“臧臧”,”utf-8”) 编码 URLDecoder.decode(cookie.getValue(),”UTF-8”) 解码 Session 什么是Session： ​ 服务器会给每个用户创建一个Session对象 ​ 一个Session单独占一个浏览器，只要浏览器没有关闭这个Session就存在 用户登录之后整个网站他都可以访问(意思就是你登录的你b站首页，然后去b站商城啥的都不用重新登录了) Session和Cookie的区别 - Cookie是把用户的数据写到浏览器中，浏览器保存而且可以保存多个 - Session是把用户的数据写到用户独占的Session中服务端保存(保存重要的信息，减少对资源的浪费) - Session对象是由服务器创建的 使用Session 12345678910111213141516171819202122232425262728protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); HttpSession session = req.getSession();//获取session session.setAttribute(&quot;name&quot;, new Pserson(&quot;臧臧&quot;,20));//保存session对象 &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); HttpSession session = req.getSession(); Pserson name = (Pserson) session.getAttribute(&quot;name&quot;);//获得session对象 System.out.println(name.getName()+&quot;现在&quot;+name.getAge()); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; 会话自动过期 12345&lt;!--设置Session默认的失效时间--&gt;&lt;session-config&gt; &lt;!--15分钟后Session自动失效，以分钟为单位--&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;","path":"2021/08/08/Cookie和Session详解/","date":"08-08","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"关于博客基于leancloud实现留言板和评论功能","text":"Valine 评论系统我使用的是这个，因为，我想让我的网站拥有一套评论系统。 ps: 注册 leancloud 国际版，不要使用国内版本。 使用 Valine 评论系统，这款系统不需要登录便可以留言，没有后端，Next 主题最新已经支持安装 基于 Leancloud 的系统 支持 MarkDown 语法 无后端实现，快速高效 配置 首先要注册Leancloud，登录官网然后进行注册，注册成功之后要验证邮箱然后创建应用，选择开发版，创建之后会自动生成App ID和App Key 对其进行配置 2.1 首先进入其主题配置文档_config.yml文件然后修改关于valine的配置 12345678910valine: enable: true # 是否开启 appid: # 上一步获取的 App ID appkey: # 上一步获取的 App Key notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: mm # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 # pagination size #默认单页的留言条数 重新部署 评论管理如果想要管理评论，进入 leancloud 官网，找到 控制台-&gt;存储-&gt;结构化数据-&gt;Comment 中进行管理 有的人想要评论后，邮箱通知，可以使用 Valine-Admin 安全中心在 leancloud 设置 -&gt; 安全中心 ，把 文件上传、短信服务、推送服务、实时通信 这几个服务全部关闭，因为用不到。然后需要特别注意的就是 Web 安全域名 这一个选项，里面一定要填写自己站点的域名，并且带上端口号，例如 http 请求的默认端口就是 80，https 请求的默认端口就是 443。这里如果没有配置好，评论的时候也会失败的","path":"2021/08/05/关于博客基于leancloud实现留言板和评论功能/","date":"08-05","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zangblog.gitee.io/tags/Hexo/"}]},{"title":"IDEA快捷键","text":"ctrl+shift+alt：多行操作psvm：生成main()方法；fori：生成for循环；Ctrl+Alt+v：自动补齐返回值类型ctrl+o：覆写方法ctrl+i：实现接口中的方法ctrl+shift+u：大小写转换CTRL+SHIFT+Z：取消撤销Alt＋Insert：生成构造方法、getter、setterctrl+y：删除当前行Ctrl+Shift+J：将选中的行合并成一行ctrl+g：定位到某一行Ctrl+Shitft+向下箭头：将光标所在的代码块向下整体移动Ctrl+Shift+向上箭头：将光标所在的代码块向上整体移动Alt+Shift+向下箭头：将行向下移动Alt+Shift+向上箭头：将行向上移动Ctrl+F：在当前文件中查找Ctrl+R：替换字符串Ctrl+Shift+F:在全局文件中查找字符串Ctrl+Shift+R：在全局中替换字符串Ctrl+Shift+Enter：自动补齐{}或者分号;Shift+Enter：在当前行的下方开始新行Ctrl+Alt+Enter：在当前行的上方插入新行Ctrl+Delete：删除光标所在至单词结尾处的所有字符","path":"2021/08/03/IDEA快捷键/","date":"08-03","excerpt":"","tags":[{"name":"技巧","slug":"技巧","permalink":"https://zangblog.gitee.io/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"Servlet的声明周期","text":"执行Servlet构造器方法 执行init初始化方法 第一第二步是在第一次访问时创建Servlet程序会调用。 执行service方法 第三步每次访问都会调用 执行destroy方法 第四部在web工程停止时调用","path":"2021/08/03/Servlet的生命周期/","date":"08-03","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"ServletContext对象","text":"ServletContext应用获取初始化参数可以在web.xml下配置初始化参数使用context-param里边的param-name为键，param-value为值， 123456789public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); ServletContext servletContext = this.getServletContext(); String url = servletContext.getInitParameter(&quot;url&quot;); resp.getWriter().print(url); &#125; 然后使用getServletContext()的getInitParameter方法获取值，此方法就位获取初始化的参数 转发1234567public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;进入了Demo05&quot;); ServletContext context = this.getServletContext(); context.getRequestDispatcher(&quot;/csh&quot;).forward(req,resp); &#125; 转发为地址不变然后跳转，转发和重定向的理解可以用这样一个场景来简单形容 张三想借钱和李四去借结果李四也没钱了出于人际关系李四就帮助张三去和王五借钱然后将借来的钱给了张三，在整个过程中张三并没有和王五有任何交集==这就是转发==张三想借钱去和李四接，结果李四也没有钱了然后就告诉张三王五那有钱让张三去和王五借，然后张三就又去和王五借钱。==这就是重定向== 这个可以用一个图来形容 上边图就为转发，下边为重定向，abc分别是张三李四王五。 读取资源文件Properties 在java目录下新建properties 在resources目录下新建properties 我们发现他们都被打包到了同一个路径下：classes，俗称为classpath 12345678910public class ServletDemo06 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;); Properties properties = new Properties(); properties.load(is); String name = properties.getProperty(&quot;user&quot;); String psw = properties.getProperty(&quot;password&quot;); resp.getWriter().print(&quot;xingming:&quot;+name+psw); &#125; 创建一个servletcontext对象然后使用getResourceAsStream方法获得流创建properties对象调用load方法将流丢入 使用getProperty方法可以读取其中数据","path":"2021/08/03/ServletContext对象/","date":"08-03","excerpt":"","tags":[{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"}]},{"title":"algolia搜索功能部署","text":"关于Hexo博客使用algolia进行搜索功能安装部署我在这个过程中遇到很多问题为了防止更多小伙伴跳坑在此写一个教程 首先要前往Algolia官网进行注册，注册一个新用户。可以使用GitHub或者Google账户直接登录 注册完成后创建一个新的Index以备后面使用 接下来要按照Hexo Algolia扩展，这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装： 1npm install --save hexo-algolia 新建一个API Key 然后 这个ACL里边根据需求添加功能，我是为了以防万一都添加了 在站点根目录下的_config.yml文件中新增以下配置 123456algolia: applicationID: &#x27;你的applicationID&#x27; apiKey: &#x27;你刚刚创建的apikey&#x27; adminApiKey: &#x27;你的adminapikey&#x27; indexName: &#x27;index的名字&#x27; chunkSize: 5000 之后在博客根目录右击git bash 123export HEXO_ALGOLIA_INDEXING_KEY=&#x27;你刚刚新创建的APIKEY&#x27;hexo algolia 修改主题内的_config.yml 启动即可 1hexo s","path":"2021/08/02/algolia搜索功能部署/","date":"08-02","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zangblog.gitee.io/tags/Hexo/"}]},{"title":"多态的自我理解","text":"Java多态有多种表现形式 普通类的多态 抽象类的多态 接口的多态 ==但是必须要存在继承关系==有自上而下转型或者自下而上转型，而自下而上转型是自动的比如我们创建一个父亲类然后两个子类，一个儿子类一个女儿类，儿子类和女儿类同时继承的父类的eat方法，而儿子类存在自己单独的跑步方法。 123456789101112131415161718192021222324252627282930313233package ManyT;public class Test &#123; public static void main(String[] args) &#123; Father father = new Son(); Father father1 = new Daughter(); Son son =(Son) new Father(); father.eat(); father1.eat(); son.run(); &#125;&#125;class Father &#123; void eat()&#123; System.out.println(&quot;父亲吃肉&quot;); &#125;&#125;class Son extends Father&#123; @Override void eat() &#123; System.out.println(&quot;儿子吃白菜&quot;); &#125; void run()&#123; System.out.println(&quot;儿子再跑&quot;); &#125;&#125;class Daughter extends Father&#123; @Override void eat() &#123; System.out.println(&quot;女儿吃萝卜&quot;); &#125;&#125; 自下向上转型首先定义方法为 父类类型 [父类变量名] = new 子类类型(); 此时这个父类变量名字可以调用子类的方法。 ==注意：如果父类中的方法是静态的(static)，子类中的同名方法也是静态的(static)，多态调用的依然是父类的成员方法。原因：静态属于类，不属于对象；多态性是针对对象而言的，和静态无关。所以用父类的引用 调用静态方法必然是执行父类的方法。）== 12Father father = new Son();father.eat(); 此时输出儿子在吃 自上向下转型定义方法为 子类类型 [子类变量名] = ==(子类类型)== new 父类类型(); 此时可以调用该子类单独的方法 12Son son = (Son) new Father();son.run(); 此时调用son独有的方法输出儿子在跑。","path":"2021/08/02/多态的自我理解/","date":"08-02","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://zangblog.gitee.io/tags/java/"}]},{"title":"静态代理模式简单理解","text":"静态代理 所谓静态代理模式，简单来说就是 一般你需要用你的王者号登陆打排位上分以及领奖励，但是静态代理就是，你把你的号给了一个代练，代练知道你的账号密码然后给你打排位领奖励就是这个意思写一个简单实例 1234567891011121314151617181920212223242526272829303132public class Staticwzry &#123; public static void main(String[] args) &#123; Boss you = new Boss(); //把真实对象传给代理 BlackSlaves blackSlaves = new BlackSlaves(you); blackSlaves.loading(); &#125;&#125;//一个登录信息的接口interface information&#123; void loading();&#125;//创建一个老板类，老板只需要进行登录账号就可class Boss implements information&#123; @Override public void loading() &#123; System.out.println(&quot;账号密码登录&quot;); &#125;&#125;//创建一个黑奴类，需要知道老板账号密码进行登录并且代练class BlackSlaves implements information &#123; private information boss; //有参构造方法，将老板传给黑奴 public BlackSlaves(information boss) &#123; this.boss = boss; &#125; @Override public void loading() &#123; this.boss.loading(); System.out.println(&quot;打排位，领奖励&quot;); &#125;&#125; 代理对象可以做很多真实对象做不了的事情真实对象只需要做自己该做的事情就行","path":"2021/08/02/静态代理模式简单理解/","date":"08-02","excerpt":"","tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://zangblog.gitee.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]}],"categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zangblog.gitee.io/tags/SpringBoot/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://zangblog.gitee.io/tags/MyBatis-Plus/"},{"name":"Linux","slug":"Linux","permalink":"https://zangblog.gitee.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://zangblog.gitee.io/tags/Nginx/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zangblog.gitee.io/tags/SpringMVC/"},{"name":"Spring5","slug":"Spring5","permalink":"https://zangblog.gitee.io/tags/Spring5/"},{"name":"反射","slug":"反射","permalink":"https://zangblog.gitee.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zangblog.gitee.io/tags/MyBatis/"},{"name":"技巧","slug":"技巧","permalink":"https://zangblog.gitee.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://zangblog.gitee.io/tags/Mybatis/"},{"name":"MyaBtis","slug":"MyaBtis","permalink":"https://zangblog.gitee.io/tags/MyaBtis/"},{"name":"MySql","slug":"MySql","permalink":"https://zangblog.gitee.io/tags/MySql/"},{"name":"javaweb","slug":"javaweb","permalink":"https://zangblog.gitee.io/tags/javaweb/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zangblog.gitee.io/tags/Hexo/"},{"name":"java","slug":"java","permalink":"https://zangblog.gitee.io/tags/java/"},{"name":"代理模式","slug":"代理模式","permalink":"https://zangblog.gitee.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]}